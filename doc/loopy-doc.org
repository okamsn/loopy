#+title: Loopy: A Looping and Iteration Macro
#+author: Earl Hyatt
#+export_file_name: loopy

# Make sure to export all headings as such.  Otherwise, some links to
# sub-headings won’t work.
#+options: H:6
# Some parsers require this option to export footnotes.
#+options: f:t

# Texinfo settings.
#+TEXINFO_FILENAME: loopy.info
#+TEXINFO_DIR_CATEGORY: Emacs
#+TEXINFO_DIR_TITLE: Loopy: (loopy)
#+TEXINFO_DIR_DESC: A looping and iteration macro.

#+MACRO: dfn @@texinfo:@dfn{$1}@@

#+begin_export html
NOTE: This file is meant for viewing in Org mode or for exporting to Texinfo.
Features might not work in other formats (e.g., Info links in HTML).
#+end_export

~loopy~ is a macro meant for iterating and looping.  It is similar in usage to
~cl-loop~ ([[info:cl#Loop Facility]]) but uses symbolic expressions rather than
keywords.

For most use cases, ~loopy~ should a nice substitute for ~cl-loop~ and
complementary to the features provided by the =seq= ([[info:elisp#Sequence Functions]])
and =cl-lib= ([[info:cl]]) libraries and Emacs's regular looping and mapping features.

-----

# This auto-generated by toc-org.
* Table of Contents                                                :TOC:noexport:
- [[#introduction][Introduction]]
- [[#basic-concepts][Basic Concepts]]
- [[#special-macro-arguments][Special Macro Arguments]]
- [[#loop-commands][Loop Commands]]
  - [[#generic-evaluation][Generic Evaluation]]
  - [[#iteration][Iteration]]
  - [[#accumulation][Accumulation]]
  - [[#boolean][Boolean]]
  - [[#control-flow][Control Flow]]
  - [[#sub-loops][Sub-loops]]
- [[#the-loopy-iter-macro][The ~loopy-iter~ Macro]]
- [[#using-flags][Using Flags]]
- [[#custom-aliases][Custom Aliases]]
- [[#custom-commands][Custom Commands]]
  - [[#background-info][Background Info]]
  - [[#hello-world][Hello World]]
  - [[#an-always-command][An ~always~ Command]]
  - [[#finding-more-examples][Finding More Examples]]
- [[#comparing-to-cl-loop][Comparing to ~cl-loop~]]
- [[#translating-cl-loop][Translating =cl-loop=]]
  - [[#for-clauses][For Clauses]]
  - [[#iteration-clauses][Iteration Clauses]]
  - [[#accumulation-clauses][Accumulation Clauses]]
  - [[#other-clauses][Other Clauses]]
-  [[#real-world-examples][Real-World Examples]]
- [[#macro-argument-and-loop-command-index][Macro Argument and Loop Command Index]]
- [[#variable-index][Variable Index]]
- [[#concept-index][Concept Index]]
- [[#footnotes][Footnotes]]

* Introduction
  :PROPERTIES:
  :DESCRIPTION: A short overview.
  :END:

  The ~loopy~ macro is used to generate code for a loop, similar to ~cl-loop~.
  Unlike ~cl-loop~, ~loopy~ uses symbolic expressions instead of "clauses".

  #+begin_src emacs-lisp
    ;; A simple usage of `cl-loop':
    (cl-loop for i from 1 to 10
             if (cl-evenp i) collect i into evens
             else collect i into odds
             end ; This `end' keyword is optional here.
             finally return (list odds evens))

    ;; How it could be done using `loopy':
    (loopy (list i (number-sequence 1 10))
           (if (cl-evenp i)
               (collect evens i)
             (collect odds i))
           (finally-return odds evens))
  #+end_src

  ~loopy~ supports destructuring for iteration commands like =list= and
  accumulation commands like =sum= or =collect=.

  #+begin_src emacs-lisp
    ;; Summing the nth elements of arrays:
    ;; => (8 10 12 14 16 18)
    (loopy (list (list-elem1 list-elem2)
                 '(([1 2 3] [4 5 6])
                   ([7 8 9] [10 11 12])))
           (sum [sum1 sum2 sum3] list-elem1)
           (sum [sum4 sum5 sum6] list-elem2))

    ;; Or, more simply:
    ;; => (8 10 12 14 16 18)
    (loopy (list list-elem '(([1 2 3] [4 5 6])
                             ([7 8 9] [10 11 12])))
           (sum ([sum1 sum2 sum3] [sum4 sum5 sum6])
                list-elem))

    ;; Separate the elements of sub-list:
    ;; => ((1 3) (2 4))
    (loopy (list i '((1 2) (3 4)))
           (collect (elem1 elem2) i))
  #+end_src

  The ~loopy~ macro is configurable and extensible.  In addition to writing one's
  own "loop commands" (such as =list= in the example below), by using "flags",
  one can choose whether to instead use ~pcase-let~, ~seq-let~, or even the Dash
  library for destructuring.

  #+begin_src emacs-lisp
    ;; Use Seq.el to destructure an array:
    ;; => ((1 4) ([2 3] [5 6]))
    (loopy (flag seq)
           (list elem '([1 2 3] [4 5 6]))
           (collect [i &rest j] elem))
  #+end_src

  Variables like =elem=, =i=, and =j= in the example above are automatically
  ~let~-bound so as to not affect code outside of the loop.

  ~loopy~ has arguments for binding (or not binding) variables, executing code
  before/after the loop, executing code only if the loop completes, and for
  setting the macro's return value (default ~nil~).  This is in addition to the
  looping features themselves.

  All of this makes ~loopy~ a useful and convenient choice for looping and
  iteration.

  That being said, Loopy is not yet feature complete.  Please request features
  or report problems in this project’s [[https://github.com/okamsn/loopy/issues][issues tracker]].  While most cases are
  covered, full feature parity with some of the more niche uses of =cl-loop= is
  still being worked on.

* Basic Concepts
  :PROPERTIES:
  :CUSTOM_ID: basic-concepts
  :DESCRIPTION: Basic information about `loopy' and its loops.
  :END:

  Except for an optional loop name, all arguments of the ~loopy~ macro are
  symbolic expressions that create a loop, assigns variables in the lexical
  environment that surrounds the loop, adds code that runs before/after the
  loop, and sets the ultimate return value of the macro.

  For convenience and clarity, symbolic expressions that generate code in the
  loop body are called "loop commands" ([[#loop-commands][Loop Commands]]).  Symbolic
  expressions that generate code around the loop are called "special macro
  arguments" or just "macro arguments" as opposed to "loop commands"
  ([[#macro-arguments][Special Macro Arguments]]).

  "Loop commands" are the main feature of the ~loopy~ macro, such as the =list=
  in =(list i '(1 2 3))=.  A command inserts code into the loop body, but can
  also perform additional setup like initializing variables.  Many commands set
  a condition for ending the loop.

  The loop ends when any condition required by a loop command evaluates to
  false.  If no conditions are needed, the loop runs infinitely until a =return=
  or =return-from= command is reached ([[#exiting-the-loop-early][Exiting the Loop Early]]).

  Except when using accumulating loop commands ([[#accumulation-commands][Accumulation Commands]]), return
  values must be stated explicitly, either as an early return in the loop body
  via the =return= or =return-from= commands, or as part of the =finally-return=
  macro argument.  =nil= is returned by default.

  The macro is configurable.  One can add custom commands ([[#adding-custom-commands][Custom Commands]]), add
  custom command aliases ([[#custom-aliases][Custom Aliases]]), and specify macro options for a
  particular loop ([[#flags][Using Flags]]).  Each of these ideas is explained in detail
  later in this document.

* Special Macro Arguments
  :PROPERTIES:
  :CUSTOM_ID: macro-arguments
  :DESCRIPTION: Creating the environment of the loop.
  :END:

  #+cindex: special macro argument
  There are 7 special macro arguments. One, an unquoted symbol, is taken as the
  loop's name. The others, listed below, are symbolic expressions that begin
  with a keyword or one of their aliases. You do not need to use all of them.

  If a macro argument does not match one of these special 7, ~loopy~ will
  attempt to interpret it as a loop command, and throw an error if that fails.

  These special macro arguments are always processed before loop commands,
  regardless of the order of the arguments passed to ~loopy~.  As they are not
  loop commands, they cannot occur in sub-loops ([[*Sub-loops][Sub-loops]]).

  #+findex: with, let*
  - =with=, =let*= :: Declare variables before the loop.

    #+begin_src emacs-lisp
      (loopy (with (a 1) (b 2)) ...)
      (loopy (let* (a 1) (b 2)) ...)
    #+end_src

  #+findex: without, no-init
  - =without=, =no-init= :: Variables that ~loopy~ should not try to
    initialize.  ~loopy~ tries to initialize all the variables it uses in a
    ~let~-like form, but that isn’t always desired.

    #+begin_src emacs-lisp
      (let ((a 5))
        ;; Without `without', `loopy' would try to initialize `a' to nil, which would
        ;; overwrite the value of 5 above.
        (loopy (without a)
               (while (not (zerop a)))
               (expr a (1- a)))

        (loopy (no-init a)
               (while (not (zerop a)))
               (expr a (1- a))))
    #+end_src

  #+findex: before-do, before
  - =before-do=, =before=, =initially-do=, =initially= :: Run Lisp expressions
    before the loop starts.

    #+begin_src emacs-lisp
      (loopy (before-do (message "1: before loop")
                        (message "2: before loop"))
             ...)

      (loopy (before (message "1: before loop")
                     (message "2: before loop"))
             ...)

      (loopy (initially-do (message "1: initially loop")
                           (message "2: initially loop"))
             ...)

      (loopy (initially (message "1: initially loop")
                        (message "2: initially loop"))
             ...)
    #+end_src

  #+findex: after-do, after, else-do, else
  - =after-do=, =after=, =else-do=, =else= :: Run Lisp expressions after the
    loop successfully completes.  This is similar to Python’s ~else~ statement
    after a ~for~ or ~while~ loop.

    #+begin_src emacs-lisp
      (loopy (list i '(2 4 6 8))
             (when (cl-oddp i)
               (do (message "Odd number found."))
               (leave))
             (after-do (message "No odd number found.")))

      (loopy (list i '(2 4 6 8))
             (when (cl-oddp i)
               (do (message "Odd number found."))
               (leave))
             (after (message "No odd number found.")))

      (loopy (list i '(2 4 6 8))
             (when (cl-oddp i)
               (do (message "Odd number found."))
               (leave))
             (else-do (message "No odd number found.")))

      (loopy (list i '(2 4 6 8))
             (when (cl-oddp i)
               (do (message "Odd number found."))
               (leave))
             (else (message "No odd number found.")))
    #+end_src

  #+findex: finally-do, finally
  - =finally-do=, =finally= :: Always run Lisp expressions after the loop
    exits.

    #+begin_src emacs-lisp
      (loopy (list i '(1 2 3))
             (when (cl-oddp i) (break))
             (after-do (message "This not messaged."))
             (finally-do (message "This always messaged.")))

      (loopy (list i '(1 2 3))
             (when (cl-oddp i) (break))
             (after-do (message "This not messaged."))
             (finally (message "This always messaged.")))
    #+end_src

  #+findex: finally-return
  - =finally-return= :: Return a value, regardless of how the loop completes.
    Accumulation commands have an implicit return value, but this argument
    overrides them.  Specifying multiple return values is the same as returning
    a list of those values.  This is convenient when used with ~seq-let~,
    ~pcase-let~, ~cl-destructuring-bind~, and the like.

    #+begin_src emacs-lisp
      (loopy (list i '(1 2 3))
             (when (cl-oddp i)
               (return "This return value is over-ridden."))
             (finally-return "This string always returned."))

      ;; => (1 2 3)
      (loopy (repeat 0)
             (finally-return 1 2 3))
    #+end_src

  #+findex: flag, flags
  - =flag=, =flags= :: Options that change the behavior of ~loopy~
    ([[*Changing the Macro's Behavior with Flags][Changing the Macro's Behavior with Flags]]).

    #+begin_src emacs-lisp
      (loopy (flag dash)
             (list (whole &as a b) '((1 2) (3 4)))
             ...)

      (loopy (flags dash)
             (list (whole &as a b) '((1 2) (3 4)))
             ...)
    #+end_src


  As stated above, all other expressions will be considered loop commands
  ([[#loop-commands][Loop Commands]]).


  #+ATTR_TEXINFO: :tag Note
  #+BEGIN_QUOTE
  For convenience, the ~while~-loop that ~loopy~ creates is wrapped by a
  ~cl-block~.  Naming the loop names this block, which is created /after/
  initializing variables.

  The two special macro arguments =before-do= and =after-do= (and their aliases)
  also occur within this ~cl-block~, before and after the loop, respectively.
  This has 2 consequences:

  1. Using ~cl-return~ in =before-do= will prevent the both loop and =after-do=
     code from running.

  2. Using ~cl-return~ or an early exit command ([[#exiting-the-loop-early][Early Exit]]) in the loop will
     prevent the =after-do= code from running.  For this reason, =after-do= is
     run if and only if the loop completes successfully, hence the alias
     =else-do= and the similarity to Python's ~else~ statement for loops.

  These three sections (=before-do=, =after-do=, and the ~while~-loop itself)
  are the only structures that occur within the ~cl-block~.  Using ~cl-return~
  in =before-do=, for example, will not stop code in =finally-do= from running
  or values listed in =finally-return= from being returned.
  #+END_QUOTE

* Loop Commands
  :PROPERTIES:
  :CUSTOM_ID: loop-commands
  :DESCRIPTION: The main features of `loopy'.
  :END:

  #+cindex: loop command
  If a macro argument does not match one of the previously listed special macro
  arguments ([[#macro-arguments][Special Macro Arguments]]), ~loopy~ will attempt to treat it as a
  loop command.  Loop commands are only valid as a top-level argument to the
  macro, or inside another loop command.

  Therefore, these macro calls are valid:

  #+BEGIN_SRC emacs-lisp
    (loopy (list i '(1 2 3))
           (collect coll i)
           ;; Special macro argument:
           (finally-return coll))

    ;; Implicit accumulation variable and implicit return value:
    (loopy (list i '(1 2 3))
           (collect i))
  #+END_SRC

  and this is not:

  #+BEGIN_SRC emacs-lisp
    (loopy (with (list i '(1 2 3)))
           (finally-return (collect coll i)))
  #+END_SRC

  Trying to use loop commands where they don't belong will result in errors
  when the code is evaluated.

  You should keep in mind that commands are evaluated in order.  This means that
  attempting to do something like the below example might not do what you
  expect, as =i= is assigned a value from the list after collecting =i= into
  =coll=.

  #+caption: An example of how loop commands are evaluated in order.
  #+BEGIN_SRC emacs-lisp
    ;; => (nil 1 2)
    (loopy (collect coll i)
           (list i '(1 2 3))
           (finally-return coll))
  #+END_SRC

  For convenience and understanding, the same command might have multiple names,
  called {{{dfn(aliases)}}}.  For example, the command =expr= has an alias
  =set=, because =expr= is used to set a variable to the value of an expression.
  You can add custom aliases using the function ~loopy-defalias~, which modifies
  the user option ~loopy-custom-command-aliases~ ([[#custom-aliases][Custom Aliases]]).

  Some commands take optional arguments.  For example, the command =list= can
  take a function as an optional argument, which affects how that iterates
  through the elements in the list.

  For simplicity, the commands are described using the following notation:

  - If a command has multiple names, the names are separated by a vertical
    bar, such as in =expr|set=.
  - =VAR= is an unquoted symbol that will be used as a variable name, such as
    =i= in =(list i my-list)=.
  - =FUNC= is a Lisp function name, such as =my-func=, =#'my-func= or
    ='my-func=.
  - =NAME= is an unquoted name of a loop (or, more accurately, of a
    =cl-block=).
  - =EXPR= is a single Lisp expression, such as =(+ 1 2)=, ='(1 2 3)=,
    =my-var=, or =(some-function my-var)=.  =EXPRS= means multiple expressions.
    Really, we are concerned with the value of the expression, not the
    expression itself.
  - =CMD= is a loop command, as opposed to a normal Lisp expression.
    =(list i '(1 2 3))=, =(repeat 5)=, and =(return-from outer-loop 7)=
    are examples of loop commands.  =CMDS= means multiple commands.
  - Optional arguments are surround by brackets.  =[EXPR]= is an optional
    expression, and =[CMD]= is an optional command.  By extension,
    =[EXPRS]= is equivalent to =[EXPR [EXPR [...]]]=, and =[CMDS]= to
    =[CMD [CMD [...]]]=.

  Generally, =VAR= is initialized to ~nil~, but not always.  This document
  tries to note when that is not the case.

  #+cindex: variable destructuring
  For convenience, =VAR= can be a sequence, either a list or a vector (as a
  stand-in for an array), of symbols instead of a single symbol.  This tells
  the command to “de-structure” the value of =EXPR=, similar to the functions
  ~seq-let~, ~cl-destructuring-bind~, and ~pcase-let~.  This sequence of
  symbols can be shorter than the destructured sequence, /but not longer/.  If
  shorter, the unassigned elements of the list are simply ignored.  To assign
  the final ~cdr~ of a destructured list, use dotted notation.

  #+caption: Several examples of destructuring.
  #+begin_src emacs-lisp
    ;; => [(9 10 11 4) (9 10 11 8)]
    (loopy (with (my-array [(1 2 3 4) (5 6 7 8)]))
           (array-ref (i j k) my-array)
           ;; NOTE: The remaining elements are ignored.
           (do (setf i 9)
               (setf j 10)
               (setf k 11))
           (finally-return my-array))

    ;; => ([9 10 11 4] [9 10 11 8])
    (loopy (with (my-list '([1 2 3 4 ] [5 6 7 8])))
           (list-ref [i j k] my-list)
           ;; NOTE: The remaining elements are ignored.
           (do (setf i 9)
               (setf j 10)
               (setf k 11))
           (finally-return my-list))

    ;; => (1 (2 3))
    (loopy (list (i . j) '((1 2 3)))
           (finally-return i j))

    ;; => ((1 22))
    (loopy (with (my-list '((1 2 3))))
           (list-ref (_ . j) my-list)
           (do (setf j '(22)))
           (finally-return my-list))

    ;; => [(1 22)]
    (loopy (with (my-array [(1 2 3)]))
           (array-ref (_ . j) my-array)
           (do (setf j '(22)))
           (finally-return my-array))
  #+end_src

  Most commands that assign variables (even the =-ref= commands, which use
  ~setf~-able places instead of actual variables) can use destructuring, but
  not all kinds of destructuring make sense in all situations.


** Generic Evaluation
   :PROPERTIES:
   :DESCRIPTION: Setting variables, evaluating expressions, etc.
   :CUSTOM_ID: commands-for-generic-evaluation
   :END:

   #+findex: do
   - =(do EXPRS)= :: Evaluate multiple Lisp expressions, like a =progn=.

     You cannot include arbitrary code in the loop body.  Trying to do so will
     result in errors, as the macro will attempt to interpret such code as a
     command.

     #+BEGIN_SRC emacs-lisp
       (loopy (list i '(1 2 3))
              (do (message "%d" i)))
     #+END_SRC

   #+findex: expr, exprs, set
   - =(expr|exprs|set VAR [EXPRS])= :: Bind =VAR= to each =EXPR= in order.
     Once the last =EXPR= is reached, it is used repeatedly for the rest of the
     loop.  With no =EXPR=, =VAR= is repeatedly bound to =nil=.

     #+ATTR_TEXINFO: :tag Note
     #+begin_quote
     =expr= does /not/ behave the same as ~setq~ in all situations.

     While =expr= can take multiple arguments, it only assigns the value of one
     expression to one variable during each iteration of the loop (unless using
     destructuring).  It cannot take pairs of variables and values in the same
     way that ~setq~ does.

     Furthermore, variables assigned by =expr= (and other commands) are by
     default ~let~-bound around the loop and generally initialized to ~nil~.
     This means that doing =(expr VAR EXPR)= will not, by default, affect
     variables outside of the loop in the same way that using =(do (setq VAR
     EXPR))= would.
     #+end_quote

     #+BEGIN_SRC emacs-lisp
       (loopy (repeat 5)
              (expr i 1 2 3)
              (collect coll i)
              (finally-return coll)) ; => '(1 2 3 3 3)

       (loopy (repeat 5)
              (expr i 0 (1+ i))
              (collect coll i)
              (finally-return coll)) ; => '(0 1 2 3 4)
     #+END_SRC

   #+findex: group
   - =(group [CMDS])= :: Evaluate multiple loop commands, as if in a =progn=.
     This is similar to =do=, but runs commands instead of normal Lisp
     expressions.  Currently, this command is only useful when used with the
     =if= command.

** Iteration
   :PROPERTIES:
   :CUSTOM_ID: iteration-and-looping-commands
   :DESCRIPTION: Iterating through sequences, etc.
   :END:

   Iteration commands bind local variables and determine when the loop ends.
   If no command sets that condition, then the loop runs forever.

   Iteration commands must occur in the top level of the ~loopy~ form or in a
   =sub-loop= command.  Trying to do something like the below will signal an
   error.

   #+begin_src emacs-lisp
     (loopy (list i '(1 2 3 4 5))
            (when (cl-evenp i)
              ;; Can't use `list' in a `when'.
              ;; Will signal an error.
              (list j '(6 7 8 9 10))
              (collect j)))
   #+end_src

   The =-ref= (as in “reference”) commands create ~setf~-able places instead of
   true variables.  Like other commands, they too can use destructuring, in
   which case the variables in the sequence =VAR= are also ~setf~-able places
   instead of true variables.

   #+ATTR_TEXINFO: :tag Note
   #+begin_quote
   In ~loopy~, iteration commands are named after what they iterate through.
   For example, =array= and =list= iterate through the elements of arrays and
   lists, respectively.  For the convenience of familiarity, these commands also
   have aliases based on their equivalent =for=-clause from ~cl-loop~.

   To translate =for VAR in LIST= from ~cl-loop~ to ~loopy~, one can use either
   =(list VAR LIST)= or =(in VAR LIST)=.  This can be helpful when using
   ~loopy-iter~ ([[#loopy-iter][The ~loopy-iter~ Macro]]), in which case you could write any of
   =(for list VAR LIST)=, =(for in VAR LIST)=, or =(in VAR LIST)=, depending on
   whether you have enabled the =lax-naming= flag.
   #+end_quote

   The available iteration commands are:

   #+findex: array, across
   - =(array|across VAR EXPR)= :: Loop through the elements of the array =EXPR=.

     #+BEGIN_SRC emacs-lisp
       (loopy (array i [1 2 3])
              (do (message "%d" i)))
     #+END_SRC

   #+findex: array-ref, arrayf, across-ref
   - =(array-ref|arrayf|across-ref VAR EXPR)= :: Loop through the elements of the array
     =EXPR=, binding =VAR= as a ~setf~-able place.

     #+BEGIN_SRC emacs-lisp
       (loopy (with (my-str "cat"))
              (array-ref i my-str)
              (do (setf i ?a))
              (finally-return my-str)) ; => "aaa"
     #+END_SRC

   #+findex: cons, conses, on
   - =(cons|conses|on VAR EXPR [FUNC])= :: Loop through the cons cells of =EXPR=.
     Optionally, find the cons cells via =FUNC= instead of =cdr=.

     To avoid unneeded variables, when not destructuring, =VAR= is initialized
     to =EXPR= instead of ~nil~.

     #+BEGIN_SRC emacs-lisp
       (loopy (cons i '(1 2 3))
              (collect coll i)
              (finally-return coll)) ; => ((1 2 3) (2 3) (3))
     #+END_SRC

   #+findex: list, in
   - =(list|in VAR EXPR [FUNC])= :: Loop through the elements of the list =EXPR=.
     Optionally, update the list by =FUNC= instead of =cdr=.

     #+BEGIN_SRC emacs-lisp
       (loopy (list i (number-sequence 1 10 3)) ; Inclusive, so '(1 4 7 10).
              (do (message "%d" i)))
     #+END_SRC

   #+findex: list-ref, listf, in-ref
   - =(list-ref|listf|in-ref VAR EXPR [FUNC])= :: Loop through the elements of
     the list =EXPR=, binding =VAR= as a ~setf~-able place.  Optionally, update
     the list by =FUNC= instead of =cdr=.

     #+BEGIN_SRC emacs-lisp
       (loopy (with (my-list '(1 2 3)))
              (list-ref i my-list)
              (do (setf i 7))
              (finally-return my-list)) ; Returns '(7 7 7).
     #+END_SRC

   #+findex: repeat
   - =(repeat [VAR] EXPR)= :: Add a condition that the loop should stop after
     =EXPR= iterations.  If specified, =VAR= starts at 0, and is incremented by
     1 at the end of the loop.

     #+BEGIN_SRC emacs-lisp
       (loopy (repeat 3)
              (do (message "Messaged three times.")))

       (loopy (repeat i 3)
              (do (message "%d" i)))
     #+END_SRC

   #+findex: seq, sequence, elements
   - =(seq|sequence|elements VAR EXPR)= :: Loop through the sequence =EXPR=,
     binding =VAR= to the elements of the sequence.

     #+BEGIN_SRC emacs-lisp
       (loopy (seq i [1 2 3])
              (collect coll i)
              (finally-return coll)) ; => (1 2 3)
     #+END_SRC

   #+findex: seq-ref, seqf, sequence-ref, sequencef, elements-ref
   - =(seq-ref|seqf|sequence-ref|sequencef|elements-ref VAR EXPR)= :: Loop
     through the elements of the sequence =EXPR=, binding =VAR= as a ~setf~-able
     place.

     #+BEGIN_SRC emacs-lisp
       (loopy (with (my-seq '(1 2 3 4)))
              (seq-ref i my-seq)
              (do (setf i 7))
              (finally-return my-seq)) ; => '(7 7 7 7)
     #+END_SRC

** Accumulation
   :PROPERTIES:
   :CUSTOM_ID: accumulation-commands
   :DESCRIPTION: Accumulating values into new sequences, aggregating values, etc.
   :END:

   Accumulation commands are used to accumulate or aggregate values into a
   variable.  For example, creating a list of values or summing the elements in
   a sequence can both be done using accumulation commands.

   If needed, you can refer to the same accumulation variable in multiple
   accumulation commands, such as in the following example.

   #+begin_src emacs-lisp
     (loopy (list i '(1 2 3))
            (collect coll i)
            (collect coll (+ i 5))
            (finally-return coll)) ; => (1 6 2 7 3 8)
   #+end_src

   #+ATTR_TEXINFO: :tag Note
   #+begin_quote
   Like with other loop commands, variables created by accumulation commands
   (such as =coll= in the above example) are initialized to ~nil~ unless
   stated otherwise.
   #+end_quote

   #+cindex: accumulation destructuring
   Like iteration loop commands, accumulation commands can also use
   destructuring, in which case the destructured values are accumulated instead
   of the "whole" value.

   #+begin_src emacs-lisp
     ;; => ((1 4) (2 5) (3 6))
     (loopy (list elem '((1 2 3) (4 5 6)))
            (collect (coll1 coll2 coll3) elem)
            (finally-return coll1 coll2 coll3))

     ;; => (5 7 9)
     (loopy (list elem '((1 2 3) (4 5 6)))
            (sum (sum1 sum2 sum3) elem)
            (finally-return sum1 sum2 sum3))

     ;; Returns the same values as above.
     (loopy (list elem '((1 2 3) (4 5 6)))
            (expr sum1 (cl-first elem)  (+ sum1 (cl-first elem)))
            (expr sum2 (cl-second elem) (+ sum2 (cl-second elem)))
            (expr sum3 (cl-third elem)  (+ sum3 (cl-third elem)))
            (finally-return sum1 sum2 sum3))
   #+end_src

   #+cindex: implied/implicit return values
   Using an accumulation command implies a return value for the macro, which you
   can override using the =return= and =return-from= loop commands or the
   =finally-return= macro argument.  If there are multiple accumulation
   variables (including those created via destructuring), then the implied
   return value of the macro is a list of those accumulated values in the order
   that their respective command occurs in the loop body.  In the example below,
   note that ~my-collection~ is the first element in the list of values returned
   by the macro, even though the collection happens /after/ the first summation.
   This is because the macro sees the =collect= command before it sees the =sum=
   command.

   #+begin_src emacs-lisp
     ;; => (((4 5 6)) 5 7 9), for (`my-collection', `sum1', `sum2', `sum3')
     (loopy (list elem '((1 2 3) (4 5 6)))
            (when (equal elem '(4 5 6))
              (collect my-collection elem))
            (sum (my-sum1 my-sum2 my-sum3) elem))
   #+end_src

   #+cindex: implied/implicit accumulation results
   #+vindex: loopy-result
   Like in ~cl-loop~, you do not need to supply a variable name to accumulation
   commands.  If no accumulation variable is given, accumulation commands will
   use the variable ~loopy-result~.  This variable is accessible in the
   =after-do=, =finally-do=, and =finally-return= special macro arguments.  As a
   consequence of how the macro expands, changing the value of ~loopy-result~ in
   the =after-do= (but not =finally-do=) macro argument changes the implied
   return value of the loop.

   #+begin_src emacs-lisp
     ;; => (1 2 3)
     (cl-assert (equal (loopy (list i '(1 2 3))
                              (collect i)
                              (after-do (cl-return loopy-result)))

                       (loopy (list i '(1 2 3))
                              (collect i)
                              (finally-return loopy-result))))

     ;; => (0 1 2 3)
     (cl-assert (equal (loopy (list i '(1 2 3))
                              (collect i)
                              (else-do (push 0 loopy-result)
                                       (cl-return loopy-result)))
                       (loopy (list i '(1 2 3))
                              (collect i)
                              (finally-do (push 0 loopy-result))
                              (finally-return loopy-result))))
   #+end_src

   Like in ~cl-loop~, all accumulation commands using implied variables will
   accumulate into the same implied variable (that is, into ~loopy-result~).
   You should make sure that such commands are compatible.  For example, you
   should not try to accumulate =collect= results and =sum= results into
   ~loopy-result~, as trying to use a list as a number will cause an error.  If
   you want to collect into separate variables, just specify a variable name
   like you normally would.

   #+attr_texinfo: :tag Warning
   #+begin_quote
   You should not try to access implied accumulation results (e.g.,
   ~loopy-result~) while the loop is running.  Implied results are only required
   to be correct after the loop ends (before code in =else-do= is run), allowing
   for more efficient code.

   Furthermore, because using a =return= or =return-from= command overrides
   implied return values, using these commands can prevent implied accumulation
   results from being finalized.  Using the =leave= command, which exits the
   loop without returning a value, does not affect the correctness of implied
   results.
   #+end_quote

   You should prefer using accumulation with implied results whenever you don't
   need to access the accumulation results during the loop.  Because ~loopy~ has
   more freedom when generating implied accumulation results, using implied
   results can be much faster.

   As noted above, ~loopy~ will by default accumulate into the same implied
   variable, ~loopy-result~.  If you wish to have the speed of implied results
   while accumulating into separate variables, you should enable the =split=
   flag ([[#flags][Flags]]).  This flag will make the macro split the implied
   results of each accumulation command into a separate variable instead of
   using ~loopy-result~.  This can be much faster than using destructuring with
   accumulation commands.

   #+begin_src emacs-lisp
     ;; Both of these example give the same result, but the latter can
     ;; expand into more efficient code.

     ;; => ((1 4) (2 5) (3 6))
     (loopy (list elem '((1 2 3) (4 5 6)))
            (collect (i j k) elem))

     ;; => ((1 4) (2 5) (3 6))
     (loopy (flag split) ; Don't implicitly accumulate into `loopy-result'.
            (list (i j k) '((1 2 3) (4 5 6)))
            (collect i)        ; Without the `split' flag,
            (collect j)        ; this would just produce
            (collect k))       ; (1 2 3 4 5 6).
   #+end_src

   #+attr_texinfo: :tag Note
   #+begin_quote
   In addition to those listed below, each accumulation command has an alias of
   the command name in the present participle form (the "-ing" form).

   For example, instead of "min" or "minimize", you can use "minning" or
   "minimizing".  Instead of "sum" and "append", you can use "summing" and
   "appending".  This helps to avoid name collisions when using the ~loopy-iter~
   macro with the =lax-naming= flag enabled ([[#loopy-iter][The ~loopy-iter~ Macro]]).
   #+end_quote

   The available accumulation commands are:

   #+findex: append
   - =(append VAR EXPR)= :: Repeatedly concatenate =EXPR= to the end of =VAR=,
     as if by the function ~append~.

     #+BEGIN_SRC emacs-lisp
       ;; => '(1 2 3 4 5 6)
       (loopy (list i '((1 2 3) (4 5 6)))
              (append coll i)
              (finally-return coll))
     #+END_SRC

   #+findex: collect
   - =(collect VAR EXPR)= :: Collect the value of =EXPR= into a list, adding
     values to the end of =VAR=.

     #+BEGIN_SRC emacs-lisp
       ;; => '(1 2 3)
       (loopy (list i '(1 2 3))
              (collect i))

       ;; => '((1 2 3) ((1) (1 2) (1 2 3)))
       (loopy (list i '(1 2 3))
              ;; Collect `i' into `coll1'.
              (collect coll1 i)
              ;; Collect `coll1' into a generated variable.
              (collect coll1))
     #+END_SRC

     To add values to the front of the list, use the =push-into= command (see
     below).

   #+findex: concat
   - =(concat VAR EXPR)= :: Repeatedly =concat= the value of =EXPR= onto the end
     of =VAR=, as a string.  See the =vconcat= command for concatenating values
     into a vector.

     #+BEGIN_SRC emacs-lisp
       ;; => "abc"
       (loopy (list i '("a" "b" "c"))
              (concat str i)
              (finally-return str))
     #+END_SRC

   #+findex: count
   - =(count VAR EXPR)= :: Count the number of times that =EXPR= evaluates to a
     non-nil value.  =VAR= starts at 0 and is incremented by 1 each time.

     #+BEGIN_SRC emacs-lisp
       ;; => 3
       (loopy (list i '(1 nil 3 nil 5))
              (count non-nil-count i)
              (finally-return non-nil-count))
     #+END_SRC

   #+findex: max, maximize
   - =(max|maximize VAR EXPR)= :: Repeatedly set =VAR= to the greater of =VAR=
     and the value of =EXPR=.  =VAR= starts at =-1.0e+INF=, so that any other
     value should be greater that it.

     #+BEGIN_SRC emacs-lisp
       ;; => 11
       (loopy (list i '(1 11 2 10 3 9 4 8 5 7 6))
              (max my-max i)
              (finally-return my-max))
     #+END_SRC

   #+findex: min, minimize
   - =(min|minimize VAR EXPR)= :: Repeatedly set =VAR= to the lesser of =VAR=
     and the value of =EXPR=.  =VAR= starts at =1.0e+INF=, so that any other
     value should be less than it.

     #+BEGIN_SRC emacs-lisp
       ;; => 0
       (loopy (list i '(1 11 2 10 3 0 9 4 8 5 7 6))
              (min my-min i)
              (finally-return my-min))
     #+END_SRC

   #+findex: multiply, multiplying
   - =(multiply|multiplying VAR EXPR)= :: Repeatedly set =VAR= to the product of the
     values of EXPR.  =VAR= starts at 1.

     #+BEGIN_SRC emacs-lisp
       ;; => 120
       (loopy (list i '(1 2 3 4 5))
              (multiply 5-factorial i)
              (finally-return 5-factorial))
     #+END_SRC
     
   #+findex: nconc
   - =(nconc VAR EXPR)= :: Repeatedly concatenate the value of =EXPR= onto
     =VAR= via the function ~nconc~.

     #+attr_texinfo: :tag Caution
     #+begin_quote
     Unlike the function ~append~, ~nconc~ does not concatenate copies of the
     lists, instead modifying =VAR= directly.
     #+end_quote

     #+BEGIN_SRC emacs-lisp
       ;; => '(1 2 3 4 5 6 7 8)
       (loopy (list i '((1 2 3 4) (5 6 7 8)))
              (nconc my-new-list i)
              (finally-return my-new-list))
     #+END_SRC

   #+findex: prepend
   - =(prepend VAR EXPR)= :: Repeatedly concatenate =EXPR= onto the front of
     =VAR=.

     #+begin_src emacs-lisp
       ;; => (5 6 3 4 1 2)
       (loopy (array i [(1 2) (3 4) (5 6)])
              (prepend i))

       ;; => (4 3 2 1)
       (let ((my-list '(1)))
         (loopy (without my-list)
                (array elem [(2) (3) (4)])
                (prepend my-list elem)))
     #+end_src

   #+findex: push, push-into
   - =(push|push-into VAR EXPR)= :: Collect the value of =EXPR= into a list,
     adding values to the front of =VAR= via the function ~push~.

     #+BEGIN_SRC emacs-lisp
       ;; => (3 2 1)
       (loopy (array i [1 2 3])
              (push my-list i))
     #+END_SRC

     To add values to the end of a list, use the =collect= command (see above).

   #+findex: sum
   - =(sum VAR EXPR)= :: Repeatedly set =VAR= to the sum of the values of =EXPR=
     and =VAR=.  =VAR= starts at 0.

     #+BEGIN_SRC emacs-lisp
       ;; => 10
       (loopy (list i '(1 2 3 4))
              (sum my-sum i)
              (finally-return my-sum))
     #+END_SRC

   #+findex: vconcat
   - =(vconcat VAR EXPR)= :: Repeatedly concatenate the value of =EXPR= onto the
     end of =VAR= via the function ~vconcat~.

     #+BEGIN_SRC emacs-lisp
       ;; => [1 2 3 4 5 6]
       (loopy (list i '([1 2 3] [4 5 6]))
              (vconcat my-vector i)
              (finally-return my-vector))
     #+END_SRC

     To concatenate values as strings, see the command =concat= above.

** Boolean
   :PROPERTIES:
   :CUSTOM_ID: boolean-commands
   :DESCRIPTION: test whether a condition holds true
   :END:

   Boolean commands are used to test whether a condition holds true for elements of a sequence.

   #+findex: always
   - =(always CONDITION)= :: Return t if all values of sequence satisfy CONDITION.
      Otherwise return nil.

     #+BEGIN_SRC emacs-lisp
       ;; => t
       (loopy (list i '(1 0 1 0 1))
              (always (< i 2)))

       ;; => nil
       (loopy (list i '(1 0 1 0 1))
              (always (< i 1)))
     #+END_SRC
   
   #+findex: never
   - =(never CONDITION)= :: Return t if all values of a sequence never satisfy
     CONDITION.  Otherwise return nil.

     #+BEGIN_SRC emacs-lisp
       ;; => t
       (loopy (list i '(1 0 1 0 1))
              (never (= i 3)))

       ;; => nil
       (loopy (list i '(1 0 1 0 1))
              (never (= i 0)))
     #+END_SRC
     
   #+findex: thereis
   - =(thereis CONDITION)= :: Return CONDITION is even non-nil, immediately return its value. Otherwise return nil.
     
     #+BEGIN_SRC emacs-lisp
       ;; => 3
       (loopy (list i '(1 0 1 3 1))
              (thereis (and (> i 2) i)))

       ;; => nil
       (loopy (list i '(1 0 1 0 1))
              (thereis (and (> i 2) i)))
     #+END_SRC
     
** Control Flow
   :PROPERTIES:
   :CUSTOM_ID: control-flow
   :DESCRIPTION: When to run loop commands.
   :END:

*** Conditionals
    :PROPERTIES:
    :CUSTOM_ID: conditionals
    :DESCRIPTION: Choosing if commands should run.
    :END:

    Conditional commands in =loopy= can take multiple sub-commands, and work
    like their Lisp counterparts.  There is therefore no need for an =and=
    command as used in =cl-loop=.

   #+findex: when
    - =(when EXPR CMDS)= :: Run =CMDS= only if =EXPR= is non-nil.

      #+BEGIN_SRC emacs-lisp
        ;; Get only the inner lists with all even numbers.
        ;; => '((2 4 6) (8 10 12) (16 18 20))
        (loopy (list i '((2 4 6) (8 10 12) (13 14 15) (16 18 20)))
               (when (loopy (list j i)
                            (when (cl-oddp j)
                              (return nil))
                            (else-do (cl-return t)))
                 (collect only-evens i))
               (finally-return only-evens))
      #+END_SRC

   #+findex: if
    - =(if EXPR CMDS)= :: Run the first command if =EXPR= is non-nil.
      Otherwise, run the remaining commands.

      #+BEGIN_SRC emacs-lisp
        ;; => '((7 5 3 1) (6 4 2) (3 3 3))
        (loopy (seq i [1 2 3 4 5 6 7])
               (if (cl-oddp i)
                   (push-into reversed-odds i)
                 (push-into reversed-evens i)
                 (push-into some-threes 3))
               (finally-return (list reversed-odds
                                     reversed-evens
                                     some-threes)))
      #+END_SRC

   #+findex: cond
    - =(cond [(EXPR CMDS) [...]])= :: For the first =EXPR= to evaluate to
      non-nil, run the following commands =CMDS=.

      #+BEGIN_SRC emacs-lisp
        ;; => '((2 4 6) (1 3 5) ("cat" "dog"))
        (loopy (list i '(1 2 3 "cat" 4 5 6 "dog"))
               (cond
                ((not (numberp i)) (collect not-numbers i))
                ((cl-evenp i)      (collect evens i))
                (t                 (collect odds i)))
               (finally-return evens odds not-numbers))
      #+END_SRC

*** Skipping Cycles
    :PROPERTIES:
    :CUSTOM_ID: skipping-an-iteration
    :DESCRIPTION: Immediately beginning the next iteration.
    :END:

   #+findex: skip, continue
    - =(skip|continue)= :: Go to next loop iteration.

      #+BEGIN_SRC emacs-lisp
        ;; => (2 4 6 8 12 14 16 18)
        (loopy (seq i (number-sequence 1 20))
               (when (zerop (mod i 10))
                 (skip))
               (when (cl-evenp i)
                 (push-into my-collection i))
               (finally-return (nreverse my-collection)))
      #+END_SRC

*** Early Exit
    :PROPERTIES:
    :CUSTOM_ID: exiting-the-loop-early
    :DESCRIPTION: Leaving the loop early, with or without returning values.
    :END:

    The loop is contained in a =cl-block=, and these forms are all variations
    of =cl-return-from= underneath.  Indeed, you could use =(do (cl-return-from
    NAME [EXPR]))= to achieve the same effect.

    If multiple =EXPR= are passes to the =return= or =return-from=, these
    commands will return a list of those =EXPR=.  If not =EXPR= is given, =nil=
    is returned.

    The commands =leave=, =while=, and =until= leave the current loop without
    forcing a returned value.  Unlike the =return= commands, they do not stop
    the loop from returning implied return values, such as the collection in
    their respective examples.

    #+findex: leave
    - =leave= :: Leave the current loop without forcing a return value.

      #+begin_src emacs-lisp
        ;; => (1 2 3 4)
        (loopy (list i '(1 2 3 4 5 6 7))
               (if (= i 5)
                   (leave)
                 (collect i)))
      #+end_src

    #+findex: return loop command
    - =(return [EXPRS])= :: Leave the current loop, returning =[EXPRS]=.

      #+BEGIN_SRC emacs-lisp
        (loopy (with  (j 0))
               (do (cl-incf j))
               (when (> j 5)
                 (return j))) ; => 6
      #+END_SRC

    #+findex: return-from
    - =(return-from NAME [EXPRS])= :: Leave the loop =NAME=, returning =[EXPRS]=.

      #+BEGIN_SRC emacs-lisp
        ;; => 'bad-val?
        (loopy outer-loop
               (list inner-list '((1 2 3) (1 bad-val? 1) (4 5 6)))
               (do (loopy (list i inner-list)
                          (when (eq i 'bad-val?)
                            (return-from outer-loop 'bad-val?)))))
      #+END_SRC

    #+findex: while
    - =(while COND)= :: Leave the loop once =COND= is false, without forcing a
      return value.

      #+begin_src emacs-lisp
        ;; => (1 2 3 4)
        (loopy (list i '(1 2 3 4 5 6 7))
               (while (not (= i 5)))
               (collect i))
      #+end_src

    #+findex: until
    - =(until COND)= :: Leave the loop once =COND= is true, without forcing a
      return value.

      #+begin_src emacs-lisp
        ;; => (1 2 3 4)
        (loopy (list i '(1 2 3 4 5 6 7))
               (until (= i 5))
               (collect i))
      #+end_src

** Sub-loops
   :PROPERTIES:
   :DESCRIPTION: Running a loop within a loop.
   :END:

   #+findex: sub-loop, subloop, loop
   - =(sub-loop|subloop|loop [CMDS])= :: Create a sub-loop in the same lexical
     environment as the top-level loop.


   There are two main ways to have a sub-loop in ~loopy~:

   1. Use another ~loopy~ call in a =do= command.
   2. Use the =sub-loop= (aliases =loop= and =subloop=) command.

   =sub-loop= is better for accumulating into variables, as is does not create
   its own result variable (unlike calling ~loopy~ again).  When using the
   =sub-loop= command, keep in mind the following:

   1. Only loop commands are valid within a sub-loop, not special macro
      arguments like =with= or =finally-return=.

      #+begin_src emacs-lisp
        ;; GOOD:
        ;; => (8 9 10)
        (loopy (with (a 7))
               (repeat 1)
               (loop (list i '(1 2 3))
                     (collect (+ a i))))

        ;; BAD:
        (loopy (repeat 1)
               (loop (with (a 7))
                     (list i '(1 2 3))
                     (collect (+ a i))))
      #+end_src

   2. Sub-loops can be named, but they do not have their own return value. The
      default loop name in ~loopy~ is ~nil~ for the top-level loop, but not for
      sub-loops.  To return from the outer loop, you can use =return-from=.

      #+begin_src emacs-lisp
        ;; Return from inner1 so never reach 4.
        ;; => ((3 5) (3 5))
        (loopy (repeat 2)
               (loop inner1
                     (list j '(3 4))
                     (loop (list k '(5 6 7))
                           (if (= k 6)
                               (return-from inner1)
                             (collect (list j k))))))

        ;; Can use `return-from' on `nil' to refer to the
        ;; top-level loop, if un-named. Otherwise use the name.
        (loopy (list i '(1 2 3))
               (loop (list j '(5 4 3))
                     (if (= i j)
                         (return-from nil i)
                       (collect (cons i j)))))
      #+end_src

      Because there is no return value for sub-loops, the =return= and =leave=
      commands behave similarly.

      #+begin_src emacs-lisp
        ;; => ((1 .6) (2 . 6))
        (loopy (list i '(1 2))
               (loop (list j '(6 7 8))
                     (if (= j 7)
                         (return)
                       (collect (cons i j)))))

        ;; => ((1 .6) (2 . 6))
        (loopy (list i '(1 2))
               (loop (list j '(6 7 8))
                     (if (= j 7)
                         (leave)
                       (collect (cons i j)))))
      #+end_src

   3. Variables used for iteration can be local to a sub-loop, but not
      variables used for accumulation.

      #+begin_src emacs-lisp
        ;; GOOD:
        ;; => (0 1 2 3 1 2 3)
        (loopy (repeat 2)
               (loop (list i '(1 2 3))
                     (collect my-coll i))
               (finally-return (cons 0 my-coll)))

        ;; BAD:
        ;; Would not give (0 3 3).  Instead, signals error.
        (loopy (repeat 2)
               (loop (list i '(1 2 3)))
               ;; Error:  `i' doesn't exist outside the sub-loop:
               (collect my-coll i)
               (finally-return (cons 0 my-coll)))
      #+end_src


* The ~loopy-iter~ Macro
  :PROPERTIES:
  :CUSTOM_ID: loopy-iter
  :DESCRIPTION: Embedding loop commands in arbitrary code.
  :END:

  #+cindex: loopy-iter
  #+findex: loopy-iter
  ~loopy-iter~ is a macro that allows for the embedding of loop commands inside
  arbitrary code, instead of trying to use the =do= loop command to embed
  arbitrary code in a loop.  You must use ~require~ to load this feature.

  #+attr_texinfo: :tag Warning
  #+begin_quote
  *This feature is still experimental.*  It might not work correctly in all
  circumstances.
  #+end_quote

  This macro is meant to be conceptually similar to the ~iterate~ or ~iter~
  macro provided by the Common Lisp package "Iterate" [fn:iter] (not to be
  confused with the ~iter-*~ functions provided by Emacs).

  #+begin_src emacs-lisp
    (require 'loopy-iter) ; <- Must `require' to load feature.

    ;; => (2 4 6)
    (loopy-iter (for list i '(1 2 3))
                (let ((a (* 2 i)))
                  (accum collect a)))
  #+end_src

  #+cindex: loopy-iter keywords
  #+vindex: loopy-iter-command-keywords
  To clearly distinguish between loop commands and Emacs features (such as the
  loop command =list= and the function ~list~), a loop command must be preceded
  by one of the keywords =for=, =accum=, or =exit=.  These keywords do not share
  a name with any built-in Emacs feature and are similar to the keywords used by
  other packages.

  Any keyword in the user option ~loopy-iter-command-keywords~ can be used to
  identify any loop command.  For example, =(accum collect a)= and
  =(for collect a)= are both valid ways of referring to the =collect= loop
  command in ~loopy-iter~.

  To disable this requirement, use the flag =lax-naming= ([[#flags][Using Flags]]).  When
  using =lax-naming=, ~loopy-iter~ will always prefer built-in features to loop
  commands.  E.g., "list" will always be understood as referring to the function
  ~list~ and not the loop command =list=.

  #+vindex: loopy-iter-ignored-commands
  If for some reason you wish for ~loopy-iter~ to ignore a loop command while
  using =lax-naming=, you can add that symbol to ~loopy-iter-ignored-commands~.

  Special macro arguments, already having clearly distinguishable names, do not
  need to be preceded by one of the above keywords.  However, some aliases (such
  as =let*= for =with=) will not work in ~loopy-iter~.

  #+begin_src emacs-lisp
    ;; => ((1 8) (2 9) (3 10))
    (loopy-iter (with (a 7))                ; <- Set once around loop.
                (for list elem '(1 2 3))
                (let* ((c elem)             ; <- These set inside of loop.
                       (d (+ a c)))
                  (accum collect (list c d))))
  #+end_src

  Restrictions on the placement of loop commands and special macro arguments
  still apply in ~loopy-iter~.  For example, iteration commands must still occur
  at the top level of ~loopy-iter~ or a sub-loop.

  #+begin_src emacs-lisp
    ;; BAD
    (loopy-iter (let ((a (progn
                           ;; ERROR: `list' must occur at top level.
                           (for list j '(8 9 10 11 12))
                           j)))
                  (accum collect a)))

    ;; GOOD
    ;; => (8 9 10 11 12)
    (loopy-iter (let ((a (progn
                           ;; NOTE: No restriction on placement of `expr'.
                           (for expr j 8 (1+ j))
                           (when (> j 12)
                             ;; Leave loop but don't force return value,
                             ;; allowing implicit result to be returned.
                             (exit leave))
                           j)))
                  (accum collect a)))
  #+end_src

  You should not rely on the values of the code into which loop commands
  translate.  For example, the above usage of =expr= might become a ~setq~ form,
  but that is an implementation detail and subject to change.  Best practice is
  to instead use a variable as the last expression in a ~progn~ form.

  For convenience, ~loopy-iter~ will not attempt to interpret loop commands in
  quoted code, except in sharp-quoted ~lambda~ forms.  This is because the
  ~lambda~ macro is self-quoting, and so Emacs might quote the form before it is
  seen by ~loopy-iter~.

  #+begin_src emacs-lisp
    ;; => (1 2 3)
    (loopy-iter (for list elem '(1 2 3))
                (funcall (lambda (x)
                           (accum collect x))
                         elem))

    ;; => (1 2 3)
    (loopy-iter (for list elem '(1 2 3))
                (funcall #'(lambda (x) ; <- sharp-quoted, but still interpreted
                             (accum collect x))
                         elem))
  #+end_src

  #+attr_texinfo: :tag Note
  #+begin_quote
  Nesting arbitrary code in the loop requires knowing how to understand the
  code.  You might find cases where ~loopy-iter~ interprets code incorrectly.

  Please report such cases on this project's [[https://github.com/okamsn/loopy/issues][issues tracker]].
  #+end_quote

  ~loopy~ (and so ~loopy-iter~) does not currently have all of the features of
  Common Lisp's ~iter~ macro.  Think of it more as a way to use loop commands
  embedded in arbitrary code.


* Using Flags
  :PROPERTIES:
  :CUSTOM_ID: flags
  :DESCRIPTION: Using flags to change behavior.
  :END:

  #+cindex: flag
  A "flag" is a symbol passed to the =flag= or =flags= macro argument, and
  changes the macro's behavior.  Currently, flags affect what ~loopy~ uses to
  perform destructuring (~pcase-let~, ~seq-let~, =dash=, or the default method)
  and whether accumulation commands that don't specify a variable (such as
  =(collect collect-value)=) accumulate into one or several variables.

  Flags are applied in order, so if you specify =(flags seq pcase)= ~loopy~ will
  use ~pcase-let~ for destructuring, not ~seq-let~.

  #+vindex: loopy-default-flags
  If you wish to always use a flag, you can add that flag to the list
  ~loopy-default-flags~.  These can be overridden by any flag given in the
  =flag= macro argument.

  The following flags are currently supported:

  #+cindex: pcase flag
  - =pcase= :: Use ~pcase-let~ for destructuring
    ([[info:elisp#Destructuring with pcase Patterns]]).
  #+cindex: seq flag
  - =seq= :: Use ~seq-let~ for destructuring ([[info:elisp#seq-let]]).
  #+cindex: dash flag
  - =dash= :: Use the style of destructuring found in the =dash= library
   ([[info:dash#-let]]).
  #+cindex: split flag
  - =split= :: Make accumulation commands with implicit variables accumulate into
    separate variables instead of into ~loopy-result~.
  #+cindex: lax-naming flag
  - =lax-naming= :: In ~loopy-iter~, don't require keywords when using loop
    commands ([[#loopy-iter][The ~loopy-iter~ Macro]]).
  #+cindex: default flag
  - =default= :: Use the default behavior for all options.


  For convenience, all flags (except =default=) can be undone by prefixing them
  with =-= (a dash or minus sign), which reverts ~loopy~ to its default
  behavior.

  For example, if you have set ~loopy-default-flags~ to =(dash split)= and wish
  to only use the =split= flag for a loop, you can use either =(flags default
  split)= or, more simply, =(flag -dash)=.  These prefixed flags only apply when
  the unprefixed version is active.  That is, =(flags pcase -dash)= is the same
  as just =(flags pcase)=, regardless of the value of ~loopy-default-flags~, as
  =pcase= destructuring will override all uses of =dash= destructuring as it
  comes later in the list.  Similarly, =(flags -dash dash)= and =(flags -dash
  +dash)= leave =dash= destructuring enabled, and =(flags +dash -dash)= disables
  =dash= destructuring and uses the default behavior.

  #+cindex: loopy-dash
  #+cindex: loopy-pcase
  #+cindex: loopy-seq
  The destructuring flags (=pcase=, =seq=, and =dash=) are separate libraries
  (respectively, =loopy-pcase=, =loopy-seq=, and =loopy-dash=) that must be
  loaded after =loopy=.  Currently, =loopy-dash= is a separate package.

  Below are some example of using the destructuring flags.  These flags do not
  affect the destructuring of commands using generalized variables (i.e.,
  ~setf~-able places).

  #+begin_src emacs-lisp
    ;; => (((1 (2 3)) (4 (5 6))) ; whole
    ;;     (1 4)                 ; i
    ;;     (2 5)                 ; j
    ;;     (3 6))                ; k
    (require 'loopy-dash)
    (loopy (flag dash)
           (list elem '((1 (2 3)) (4 (5 6))))
           (collect (whole &as i (j k)) elem))

    ;; => ((1 4) (3 6))
    (require 'loopy-pcase)
    (loopy (flag pcase)
           (list elem '((1 (2 3)) (4 (5 6))))
           (collect `(,a (,_ ,b)) elem))

    ;; => ((1 6) (3 8) ([4 5] [9 10]))
    (require 'loopy-seq)
    (loopy (flag seq)
           (list elem '([1 2 3 4 5] [6 7 8 9 10]))
           (collect [a _ b &rest c] elem))
  #+end_src

  The =split= flag can be more efficient than using destructuring with
  accumulation commands.  Some accumulation commands can have more efficient
  behavior when using implicit accumulation variables, since the variables can't
  be accessed until the loop ends.  Using the =split= flag allows you to do this
  easily for multiple variables.

  This can make a noticeable difference on large lists, but note that if you use
  this feature, you will not be able to access the implicit return values with
  loopy-result.  They will each have their own, uniquely generated name in
  each loop.

   #+begin_src emacs-lisp
     ;; Both of these example give the same result, but the latter
     ;; can expand into more efficient code.
     ;;
     ;; There is also the `push-into' command, which avoids this problem when
     ;; used with `nreverse'.

     ;; => ((1 4) (2 5) (3 6))
     (loopy (list elem '((1 2 3) (4 5 6)))
            (collect (i j k) elem))

     ;; => ((1 4) (2 5) (3 6))
     (loopy (flag split) ; Don't accumulate into same implicit variable.
            (list (i j k) '((1 2 3) (4 5 6)))
            (collect i)
            (collect j)
            (collect k))
   #+end_src

   Below is an example of the =split= flag.

   #+begin_src emacs-lisp
     ;; => (1 2 3 4 5)
     (loopy (flag -split)
            (list i '(1 2 3 4 5))
            (if (cl-oddp i)
                (collect i)
              (collect i))
            ;; For un-named loops, the variable is `loopy-result'.
            (finally-return loopy-result))

     ;; => ((1 3 5) (2 4))
     (loopy (flag split)
            (list i '(1 2 3 4 5))
            (if (cl-oddp i)
                (collect i)
              (collect i)))
   #+end_src


* Custom Aliases
  :PROPERTIES:
  :CUSTOM_ID: custom-aliases
  :DESCRIPTION: How to add one's own aliases.
  :END:

  #+cindex: custom aliases
  An {{{dfn(alias)}}} is another name for a command.  ~loopy~ comes with several
  built-in aliases, such as =set= for the command =expr=.

  #+vindex: loopy-custom-command-aliases
  #+findex: loopy-defalias
  Custom aliases can be added to the user option ~loopy-custom-command-aliases~.
  Each element in this list is a pair of the alias and the definition.  For
  convenience, the function ~loopy-defalias~ is provided, which will correctly
  add the pairs to this variable.

  #+begin_src emacs-lisp
    ;; You don't need to quote either of the arguments,
    ;; but you can if you prefer.
    (loopy-defalias l list)
    (loopy-defalias a 'array)

    ;; => ((1 . 4) (2 . 5) (3 . 6))
    (loopy (l i '(1 2 3))
           (a j [4 5 6])
           (collect (cons i j)))

    ;; => ((a . array) (l . list))
    loopy-custom-command-aliases
  #+end_src

  #+attr_texinfo: :tag Note
  #+begin_quote
  The macro checks for command definitions in the following order:

  1. Custom aliases
  2. Custom commands
  3. Built-in commands


  If an alias is found, the macro will check first whether it is an alias of a
  custom command, then whether it is an alias of a built-in command.
  #+end_quote

  The special macro arguments ([[#macro-arguments][Special Macro Arguments]]) can also be aliased.
  Using an alias does not change that the special arguments are parsed before
  ~loopy~ attempts to parse loop commands.

  #+begin_src emacs-lisp
    (loopy-defalias as with)

    ;; => (8 9 10)
    (loopy (as (a 7))
           (list i '(1 2 3))
           (collect (+ i 7)))
  #+end_src


* Custom Commands
  :PROPERTIES:
  :CUSTOM_ID: adding-custom-commands
  :DESCRIPTION: Extending `loopy' with personal commands.
  :END:

  This section contains information about how loop commands work and how one can
  add custom commands to ~loopy~.  Two examples are provided.

** Background Info
   :PROPERTIES:
   :CUSTOM_ID: background-info
   :DESCRIPTION: The internals of `loopy'.
   :END:

   #+cindex: instruction, instructions
   The core working of =loopy= is taking a command and generating code that is
   substituted into or around a loop body.  This code is transmitted between
   functions as {{{dfn(instructions)}}}, which describe how the code is to be
   used.

   Some examples of instructions are:
   - Declaring a given variable in a let form to make sure it's locally
     scoped.
   - Declaring a generated variable in a let form to contain a given value.
   - Adding a condition for continuing/exiting the loop.
   - Adding code to be run during the main loop body.
   - Adding code to be run after the main loop body.

   For example, parsing the command =(list i '(1 2 3))= produces the following
   list of instructions.  Some commands require the creation of unique temporary
   variables, such as =list-3717= in the below output.

   #+BEGIN_SRC emacs-lisp
     ((loopy--iteration-vars list-3717 '(1 2 3))
      (loopy--latter-body setq list-3717 (cdr list-3717))
      (loopy--pre-conditions consp list-3717)
      (loopy--main-body setq i (car list-3717))
      (loopy--iteration-vars i nil))
   #+END_SRC

   The ~car~ of an instruction is the place to put code and the ~cdr~ of the
   instruction is said code to put.  You can see that not all of the code to be
   inserted is a valid Lisp form.  Instead of being evaluated as an expression,
   some instructions insert pairs of names and values into variable lists like
   in ~let~ and ~let*~ .

   | Place                   | Code                               |
   |-------------------------+------------------------------------|
   | =loopy--iteration-vars= | =(list-3717 '(1 2 3))=             |
   | =loopy--latter-body=    | =(setq list-3717 (cdr list-3717))= |
   | =loopy--pre-conditions= | =(consp list-3717)=                |
   | =loopy--main-body=      | =(setq i (car list-3717))=         |
   | =loopy--iteration-vars= | =(i nil)=                          |

   Commands are parsed by =loopy--parse-loop-commands=, which receives a list of
   commands and returns a list of instructions.  For commands that take
   sub-commands as arguments (such as =cond=, =if=, and =when=), more specific
   parsing functions are called in a mutually recursive fashion (e.g.,
   Function-1 uses Function-2 which uses Function-1, and so on).

   For example, consider the function =loopy--parse-if-command=, which parses
   the =if= command.  It needs to be able to group any code going to the loop
   body under an ~if~-form.  To do this, it uses =loopy--parse-loop-command= to
   turn its sub-commands into a list of instructions, and then checks the =car=
   of each instruction to whether the code should be inserted into the loop's
   main body (and so whether it should be wrapped in the ~if~-form).

   #+BEGIN_SRC emacs-lisp
     (cl-defun loopy--parse-if-command
         ((_ condition &optional if-true &rest if-false))
       "Parse the `if' loop command.  This takes the entire command.

     - CONDITION is a Lisp expression.
     - IF-TRUE is the first sub-command of the `if' command.
     - IF-FALSE are all the other sub-commands."
       (let (full-instructions
             if-true-main-body
             if-false-main-body)
         (dolist (instruction (loopy--parse-loop-command if-true))
           (if (eq 'loopy--main-body (car instruction))
               (push (cdr instruction) if-true-main-body)
             (push instruction full-instructions)))
         (dolist (instruction (loopy--parse-loop-commands if-false))
           (if (eq 'loopy--main-body (car instruction))
               (push (cdr instruction) if-false-main-body)
             (push instruction full-instructions)))
         ;; Push the actual main-body instruction.
         (setq if-true-main-body
               (if (= 1 (length if-true-main-body))
                   (car if-true-main-body)
                 (cons 'progn (nreverse if-true-main-body))))

         ;; Return the list of instructions.
         (cons `(loopy--main-body
                 . (if ,condition
                       ,if-true-main-body
                     ,@(nreverse if-false-main-body)))
               (nreverse full-instructions))))
   #+END_SRC

   The hardest part of this exchange is making sure the inserted code ends up in
   the correct order.

   A loop body command has 7 main places to put code:

   #+vindex: loopy--generalized-vars
   - =loopy--generalized-vars= :: Lists of a symbol and a macro
     expansion that will be given to =cl-symbol-macrolet=.  This is used to
     create named ~setf~-able places.  The expansion you use depends on the kind
     of sequence and how the it is updated.

     For example, =(list-ref i my-list)= declares =i= to be a symbol which
     expands to =(car TEMP-VAR)=, in which =TEMP-VAR= holds the value of
     =my-list=.  At the end of the loop body, =TEMP-VAR= is set to its =cdr=,
     ensuring that the next call to =car= returns the correct value.

   #+vindex: loopy--iteration-vars
   - =loopy--iteration-vars= :: Lists of a symbol and an expression that will be
     given to ~let*~.  This is used for initializing variables needed for
     iteration commands, such as the =i= in =(list i '(1 2 3))= or to store the
     list ='(1 2 3)= in =(list i '(1 2 3))=.  This also includes variables
     needed for destructuring.

   #+vindex: loopy--accumulation-vars
   - =loopy--accumulation-vars= :: Lists of a symbol and an expression that will
     be given to ~let*~.  This is used for initializing variables needed for
     accumulation commands, such as the =coll= in =(collect coll my-val)= or any
     variables needed for destructuring.

   #+vindex: loopy--pre-conditions
   - =loopy--pre-conditions= :: Expressions that determine if the =while=
     loop runs/continues, such as whether a list still has elements in it.
     If there is more than one expression, than all expressions are used in
     an =and= special form.

   #+vindex: loopy--main-body
   - =loopy--main-body= :: Expressions that make up the main body of the
     loop.

   #+vindex: loopy--latter-body
   - =loopy--latter-body= :: Expressions that need to be run after the main
     body, such as updating some of variables that determine when a loop ends.

   #+vindex: loopy--post-conditions
   - =loopy--post-conditions= :: Expressions that determine whether the
     =while= loop continues, but checked after the loop body has run.  The
     code from this is ultimately appended to the latter body before being
     substituted in.

   For accumulation commands, you might also wish to place values in the
   following:

   #+vindex: loopy--implicit-return
   - =loopy--implicit-return= :: A list of values to be returned by the loop if
     no other return value is specified. All accumulation commands can add a
     value to this list, which can include the variable ~loopy-result~ if an
     accumulation command is used without specifying a variable.

     For example, =(collect my-coll my-val)= would add =my-coll= to this list.

   #+vindex: loopy--implicit-accumulation-final-update
   - =loopy--implicit-accumulation-final-update= :: Actions to perform on
     ~loopy-result~ after the loop ends.  Some implied accumulation commands
     need to update the variable one final time after ending the loop, such as
     making sure it is in the right order.  Although this variable is a list of
     such updates, to avoid conflicts, only the update at the head of the list
     is performed.

   There are 4 more variables a loop command can push to, but they are derived
   from the macro's arguments.  Adding to them after using a macro argument
   might lead to unintended behavior.  You might wish to use them if, for
   example, you are concerned with what happens after the loop exits/completes.

   #+vindex: loopy--before-do
   - =loopy--before-do= :: Expressions to evaluate before the loop.  These are
     derived from the =before-do= macro argument.

   #+vindex: loopy--after-do
   - =loopy--after-do= :: Expressions to evaluate after the loop completes
     successfully.  These are derived from the =after-do= macro argument.

   #+vindex: loopy--final-do
   - =loopy--final-do= :: Expressions to evaluate after the loop completes,
     regardless of success.  These are derived from the =finally-do= macro
     argument.

   #+vindex: loopy--final-return
   - =loopy--final-return= :: An expression that is always returned by the
     macro, regardless of any early returns in the loop body.  This is
     derived from the =finally-return= macro argument.

   The structure of the macro’s expanded code depends on the features used
   (e.g., =loopy= won’t try to declare variables if none exist), but the result
   will work similar to the below example.

   #+BEGIN_SRC emacs-lisp
     `(cl-symbol-macrolet ,loopy--generalized-vars
        (let* ,loopy--with-vars
          (let ,loopy--accumulation-vars
            (let* ,loopy--iteration-vars
              (let ((loopy--early-return-capture
                     (cl-block ,loopy--name-arg
                       ,@loopy--before-do
                       (while ,(cl-case (length loopy--pre-conditions)
                                 (0 t)
                                 (1 (car loopy--pre-conditions))
                                 (t (cons 'and loopy--pre-conditions)))
                         (cl-tagbody
                          ,@loopy--main-body
                          loopy--continue-tag
                          ,@loopy--latter-body))
                       ,@loopy--after-do
                       nil)))
                ,@loopy--final-do
                ,(if loopy--final-return
                     loopy--final-return
                   'loopy--early-return-capture))))))
   #+END_SRC

** Hello World
   :PROPERTIES:
   :CUSTOM_ID: a-small-example
   :DESCRIPTION: A minimal working example.
   :END:

   To implement a custom loop body command, =loopy= needs two pieces of
   information:
   1. The keyword that names your command
   2. The parsing function that can turn uses of your command into instructions.

   Importantly, your custom commands cannot share a name.

   For example, say that you're tired of typing out
   =(do (message "Hello, %s" first last))= and would prefer to instead use
   =(greet FIRST [LAST])=.  This only requires pushing code into the main
   loopy body, so the definition of the parsing function is quite simple.

   #+BEGIN_SRC emacs-lisp
     (cl-defun my-loopy-greet-command-parser ((_ first &optional last))
       "Greet one with first name FIRST and optional last name LAST."
       `((loopy--main-body . (if ,last
                                 (message "Hello, %s %s" ,first ,last)
                               (message "Hello, %s" ,first)))))
   #+END_SRC

   =loopy= will pass the entire command expression to the parsing function, and
   expects back a list of instructions.

   #+vindex: loopy-custom-command-parsers
   To tell =loopy= about this function, add it and the command name =greet= to
   the variable =loopy-custom-command-parsers=.  When ~loopy~ doesn’t recognize
   a command, it will search in this alist for a matching symbol.  The function
   that is paired with the symbol receives the entire command expressions, and
   should produce a list of valid instructions.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'loopy-custom-command-parsers
                  '(greet . my-loopy-greet-command-parser))
   #+END_SRC

   After that, you can use your custom command in the loop body.

   #+BEGIN_SRC emacs-lisp
     (loopy (list name '(("John" "Deer") ("Jane" "Doe") ("Jimmy")))
            (greet (car name) (cadr name)))
   #+END_SRC

   By running =M-x pp-macroexpand-last-sexp= on the above expression, you can
   see that it expands to do what we want, as expected.

   #+BEGIN_SRC emacs-lisp
     (let ((g815 '(("John" "Deer")
                   ("Jane" "Doe")
                   ("Jimmy")))
           (name nil))
       (while (consp g815)
         (setq name (car g815))
         (if (cadr name)
             (message "Hello, %s %s"
                      (car name) (cadr name))
           (message "Hello, %s" (car name)))
         (setq g815 (cdr g815)))
       nil)
   #+END_SRC

** An ~always~ Command
   :PROPERTIES:
   :CUSTOM_ID: always-example
   :DESCRIPTION: Adding a feature from `cl-loop'.
   :END:

   Lets say we want to emulate =cl-loop='s =always= clause, which causes the
   loop to return =nil= if an expression evaluates to =nil= and =t= otherwise.

   Here is an example:

   #+BEGIN_SRC emacs-lisp
     ;; => t
     (cl-loop for i in (number-sequence 1 9) always (< i 10))
   #+END_SRC

   Without a custom command, you could translate this using the following.

   #+BEGIN_SRC emacs-lisp
     (loopy (list i (number-sequence 1 9))
            (unless (< i 10) (return nil))
            (else-do (cl-return t)))
   #+END_SRC

   While its meaning is clear, this approach is certainly wordier.  Here's how
   you could do it with a custom command (note this is taken directly from
   =loopy-commands.el=).

   #+BEGIN_SRC emacs-lisp
     (cl-defun loopy--parse-always-command ((_ &rest conditions))
  "Parse a command of the form `(always [CONDITIONS])'.
If any condition is nil, `loopy' should immediately return nil.
Otherwise, `loopy' should return t."
       `((loopy--after-do . (cl-return t))
         (loopy--main-body . (unless (and ,@conditions) (cl-return-from ,loopy--loop-name nil)))))

(add-to-list 'loopy-custom-command-parsers (cons 'always #'my--loopy-always-command-parser))
   #+END_SRC

   Here are some examples of the command in action. Note that you can optionally
   provide more than one condition for the command. In this case the conditions
   are treated as if they were one condition joined by an "and". Thus ~(always
   (< i 10) (cl-evenp j))~ is equivalent to ~(always (and (< i 10) (cl-evenp j))))~.

   #+begin_src emacs-lisp
     ;; One condition: => t
     (loopy (list i (number-sequence 1 9)) (always (< i 10)))

     ;; Two conditions: => nil
     (loopy (list i (number-sequence 1 9))
            (list j '(2 4 6 8 9))
            (always (< i 10) (cl-evenp j)))

     ;; The previous example is equivalent to this.
     (loopy (list i (number-sequence 1 9))
            (list j '(2 4 6 8 9))
            (always (and (< i 10) (cl-evenp j))))
   #+end_src
   
** Finding More Examples
:PROPERTIES:
:ID:       bb8a79c1-1a85-463b-9349-7ee01b42c38c
:END:

To see more examples, I recommend looking at the source code of
=loopy-commands.el= which contains all of loopy's built-in commands.

* Comparing to ~cl-loop~
  :PROPERTIES:
  :CUSTOM_ID: comparing-to-cl-loop
  :DESCRIPTION: Why `loopy' instead of `cl-loop'.
  :END:

  =loopy= should be comparable with =cl-loop= for most things, keeping in
  mind the following:
  - It is probably less efficient than =cl-loop=, though I am so far trying to
    keep the same logic that =cl-loop= uses.
  - It has more flexible control-flow commands, under which you can easily group
    sub-commands, including assignments.
  - It has a =skip= command to skip the rest of the loop body and immediately
    start the next iteration.  Of course, a similar effect could be achieved
    using the =when= or =unless= commands.

  =loopy= is not always one-to-one replacement for =cl-loop=, but it is easy to
  use and extend, and performs well in the cases that it already handles.

  Below is a simple example of =loopy= vs =cl-loop=.

  #+BEGIN_SRC emacs-lisp
    (require 'cl-lib)
    (cl-loop with some-thing = 5
             for i from 1 to 100
             do (message "I is %s" i)
             when (> (+ i 5) 20)
             return (format "Done: %d" i))

    (require 'loopy)
    (loopy (with (some-thing 5))
           (list i (number-sequence 1 100))
           (do (message "I is %s" i))
           (when (> (+ i 5) 20)
             (return (format "Done: %d" i))))
  #+END_SRC

  The main benefit (I believe) of Loopy is clearer grouping of commands under
  conditionals while still using a clean syntax, such as in the below example.

  #+BEGIN_SRC emacs-lisp
    ;; => '((2 4) (4 8) (6 12) (8 16) (10 20))
    (loopy (list i (number-sequence 1 10))
           (when (cl-evenp i)
             (expr once i)
             (expr twice (* 2 i))
             (collect together (list once twice)))
           (finally-return together))
  #+END_SRC

  In my experience, =cl-loop= does not allow the easy grouping of assignment
  statements under a =when= condition.  For example, below is something I would
  like to try to do with =cl-loop=.

  I am aware that in this example the =for= statements aren't necessary and that
  the =collect= statements would be sufficient, but (when I come across things
  like this in my work) I would like to use them to declare variables for
  readability purposes.

  #+BEGIN_SRC emacs-lisp
    (require 'cl-lib)
    (save-match-data
      (cl-loop with pattern = "^Line\\([[:digit:]]\\)-Data\\([[:digit:]]\\)"
               for line in (split-string "Line1-Data1\nBad\nLine2-Data2")
               when (string-match pattern line)
               for line-num = (concat "L" (match-string 1 line))
               and for data-num = (concat "D" (match-string 2 line))

               ;; … Further processing now that data is named …

               and collect line-num into line-nums
               and collect data-num into data-nums
               finally return (list line-nums data-nums)))

    ;; Normal Elisp:
    (save-match-data
      (let ((pattern "^Line\\([[:digit:]]\\)-Data\\([[:digit:]]\\)")
            (line-nums)
            (data-nums))
        (dolist (line (split-string "Line1-Data1\nBad\nLine2-Data2"))
          (when (string-match pattern line)
            (let ((line-num (concat "L" (match-string 1 line)))
                  (datum-num (concat "D" (match-string 2 line))))

              ;; … Further processing now that data is named …

              (push line-num line-nums)
              (push datum-num data-nums))))
        (list (nreverse line-nums) (nreverse data-nums))))
  #+END_SRC

  Here is how one could currently do it with =loopy=:

  #+BEGIN_SRC emacs-lisp
    (require 'loopy)
    (save-match-data
      (loopy (with (pattern "^Line\\([[:digit:]]\\)-Data\\([[:digit:]]\\)"))
             (list line (split-string "Line1-Data1\nBad\nLine2-Data2"))
             (when (string-match pattern line)
               (expr line-num (concat "L" (match-string 1 line)))
               (expr datum-num (concat "D" (match-string 2 line)))

               ;; … Further processing now that data is named …

               (collect line-nums line-num)
               (collect data-nums datum-num))
             (finally-return line-nums data-nums)))
  #+END_SRC

  I believe that the value of the macro increases for longer loop bodies with
  several conditional commands.

  Another nice ability, one that I'm not sure =cl-loop= has, is a specific
  command for skipping/continuing a loop iteration.  Of course, one could also
  re-organize code under a conditional command like =when= to achieve the same
  effect.

  #+BEGIN_SRC emacs-lisp
    ;; Returns even numbers that aren't multiples of 10.
    (loopy (list i (number-sequence 1 20))
           (when (zerop (mod i 10))
             (skip))
           (when (cl-evenp i)
             (push-into my-collection i))
           (finally-return (nreverse my-collection))) ; => (2 4 6 8 12 14 16 18)
  #+END_SRC

* Translating =cl-loop=
  :PROPERTIES:
  :CUSTOM_ID: translating-from-cl-loop
  :DESCRIPTION: Converting `cl-loop' to `loopy', and vice versa.
  :END:

  ~loopy~ and ~cl-loop~ use slightly different terminology.  The equivalent of
  "for clauses" are referred to as "iteration commands" in ~loopy~, as they
  generally are used for iterating through sequences.  Meanwhile, "iteration
  clauses" can be separated into "iteration commands" (=repeat= and =iter-by=
  (not yet implemented)) and "early-exit commands" (=while= and =until=).

  "Accumulation clauses" work the same as "accumulation commands".

** For Clauses
   :PROPERTIES:
   :CUSTOM_ID: for-clauses
   :END:

   As Emacs has many functions that return lists, there is no need to implement
   an exact equivalent for every =for=-clause that =cl-loop= has.  Instead, one
   can just iterate through the return value of the appropriate function using
   the =list= command.

   | =cl-loop=                                     | =loopy=                                          |
   |-----------------------------------------------+--------------------------------------------------|
   | =for VAR from EXPR1 to EXPR2 by EXPR3=        | =(list VAR (number-sequence EXPR1 EXPR2 EXPR3))= |
   | =for VAR in LIST [by FUNCTION]=               | =(list VAR LIST [FUNC])=                         |
   | =for VAR on LIST [by FUNCTION]=               | =(cons VAR VAL [FUNC])=                          |
   | =for VAR in-ref LIST by FUNCTION=             | =(list-ref VAR LIST [FUNC])=                     |
   | =for VAR across ARRAY=                        | =(array VAR ARRAY)=                              |
   | =for VAR across-ref ARRAY=                    | =(array-ref VAR ARRAY)=                          |
   | =for VAR being the elements of SEQUENCE=      | =(seq VAR SEQUENCE)=                             |
   | =for VAR being the elements of-ref SEQUENCE=  | =(seq-ref VAR SEQUENCE)=                         |
   | =for VAR being the symbols [of OBARRAY]=      | None so far.  Use ~mapatoms~.                    |
   | =for VAR being the hash-keys of HASH-TABLE=   | =(list VAR (hash-table-keys HASH-TABLE))=        |
   | =for VAR being the hash-values of HASH-TABLE= | =(list VAR (hash-table-values HASH-TABLE))=      |
   | =for VAR being the key-codes of KEYMAP=       | None so far.  Use ~map-keymap~.                  |
   | =for VAR being the key-bindings of KEYMAP=    | None so far.  Use ~map-keymap~.                  |
   | =for VAR being the key-seqs of KEYMAP=        | None so far.                                     |
   | =for VAR being the overlays [of BUFFER]=      | None so far.  Use ~overlay-lists~.               |
   | =for VAR being the intervals [of BUFFER]=     | None so far.                                     |
   | =for VAR being the frames=                    | =(list VAR (frame-list))=                        |
   | =for VAR being the windows [of FRAME]=        | =(list VAR (window-list FRAME))=                 |
   | =for VAR being the buffers=                   | =(list VAR (buffer-list))=                       |
   | =for VAR = EXPR1 then EXPR2=                  | =(expr VAR EXPR1 EXPR2)=                         |

** Iteration Clauses
   :PROPERTIES:
   :CUSTOM_ID: iteration-clauses
   :END:

   | =cl-loop=          | =loopy=        |
   |--------------------+----------------|
   | =repeat INT=       | =(repeat INT)= |
   | =while COND=       | =(while COND)= |
   | =until COND=       | =(until COND)= |
   | =iter-by iterator= | None so far.   |

   The clauses =always=, =never=, and =thereis= can be replaced by a
   combination of an exiting command and the =after-do= (also written
   =else-do=) macro argument.  Below is an example from the CL Lib manual.

   #+BEGIN_SRC emacs-lisp
     ;; With `cl-loop':
     (if (cl-loop for size in size-list always (> size 10))
         (only-big-sizes)
       (some-small-sizes))

     ;; With `loopy':
     ;; Depends on whether the functions have return values.
     (loopy (list size size-list)
            ;; `return` is just a wrapper for `cl-return`.
            (when (< size 10) (return (some-small-sizes)))
            ;; Only runs if loop doesn't exit early.
            (else-do (cl-return (only-big-sizes))))
   #+END_SRC

   A seen in the above example, =loopy= does not always have a one-to-one
   translation to =cl-loop=.  For the above, an example is provided for adding
   an =always= custom command ([[#always-example]]).

   It is not an explicit goal to be able to replace all uses of =cl-loop= with
   =loopy=.  I'd prefer that =loopy= be useful in places where =cl-loop= might
   not be enough, instead of forcing =loopy= into places where =cl-loop=
   already works well.

   Other options in the above example include using =cl-every=,
   =seq-every-p=, Dash’s =-all?=, etc.

** Accumulation Clauses
   :PROPERTIES:
   :CUSTOM_ID: accumulation-clauses
   :END:

   In =loopy=, when accumulation commands are not given a =VAR=, they
   accumulate into different variables.  If you want accumulations to act on
   the same variable, you must give the same =VAR=.

   | =cl-loop=                | =loopy=              |
   |--------------------------+----------------------|
   | =append EXPR into VAR=   | =(append VAR EXPR)=  |
   | =collect EXPR into VAR=  | =(collect VAR EXPR)= |
   | =concat EXPR into VAR=   | =(concat VAR EXPR)=  |
   | =count EXPR into VAR=    | =(count VAR EXPR)=   |
   | =maximize EXPR into VAR= | =(max VAR EXPR)=     |
   | =minimize EXPR into VAR= | =(min VAR EXPR)=     |
   | =nconc EXPR into VAR=    | =(nconc VAR EXPR)=   |
   | =sum EXPR into VAR=      | =(sum VAR EXPR)=     |
   | =vconcat EXPR into VAR=  | =(vconcat VAR EXPR)= |

** Other Clauses
   :PROPERTIES:
   :CUSTOM_ID: other-clauses
   :END:

   In =loopy=, =if=, =when=, and =unless= can take multiple loop commands as
   arguments, and operate more like their Lisp counterparts.

   This means that =if= is not a synonym for =when=.  Just like the normal Lisp
   special form =if=, =(if COND cmd1 cmd2 cmd3)= only runs =cmd1= if =COND=
   evaluates to non-nil, and only runs commands =cmd2= and =cmd3= if =COND=
   evaluates to =nil=.

   =loopy= also provides the command =cond=, which works like the normal Lisp
   special form =cond=.

   | =cl-loop=              | =loopy=                                     |
   |------------------------+---------------------------------------------|
   | =with var = value=     | =(with (VAR VALUE))= as a macro argument    |
   | =if COND clause=       | =(if COND CMDS)= as a loop command          |
   | =when COND clause=     | =(when COND CMDS)= as a loop command        |
   | =unless COND clause=   | =(unless COND CMDS)= as a loop command      |
   | =named NAME=           | =NAME= as a macro argument                  |
   | =initially [do] EXPRS= | =(before-do EXPRS)= as a macro argument     |
   | =finally [do] EXPRS=   | =(finally-do EXPRS)= as a macro argument    |
   | =finally return EXPR=  | =(finally-return EXPR)= as a macro argument |
   | =do EXPRS=             | =(do EXPRS)= as a loop command              |
   | =return EXPR=          | =(return EXPR)= as a loop command           |


*  Real-World Examples
  :PROPERTIES:
  :DESCRIPTION: Extra example of how one could use `loopy'.
  :END:

  This section contains examples of loops that exist in real-world commands.  To
  see these loops in context, full examples of those commands can be found in
  the file [[file:loopy-examples.el]] (containing the library =loopy-examples=) that
  comes with this package.

  One command that could see a benefit from using =loopy= is =selectrum-swiper=
  from the Selectrum wiki [fn:sel-wiki].  This command allows a user to jump to
  a matched line in the buffer.  Candidates are created by looping through text
  lines, formatting non-empty lines and collecting the formatted lines into a
  list of candidates.  At the same time, it selects a default candidate by
  finding the non-empty line closest to the current line.

  Here is the main portion of the command, which uses =cl-loop=.

  #+begin_src emacs-lisp
    ;; ...
    (cl-loop
     with buffer-lines = (split-string (buffer-string) "\n")
     with number-format = (concat "L%0"
                                  (number-to-string
                                   (length (number-to-string
                                            (length buffer-lines))))
                                  "d: ")

     with formatted-candidates = nil
     for line-text in buffer-lines
     for line-num = (line-number-at-pos (point-min) t) then (1+ line-num)

     with default-candidate = nil
     with prev-distance-to-default-cand = 1.0e+INF ; This updated later.
     for distance-to-default-cand = (abs (- current-line-number line-num))

     unless (string-empty-p line-text)      ; Just skip empty lines.
     do
     ;; Find if we’ve started to move away from the current line.
     (when (null default-candidate)
       (when (> distance-to-default-cand
                prev-distance-to-default-cand)
         (setq default-candidate (cl-first formatted-candidates)))
       (setq prev-distance-to-default-cand distance-to-default-cand))

     ;; Format current line and collect candidate.
     (push (propertize line-text
                       'selectrum-candidate-display-prefix
                       (propertize (format number-format line-num)
                                   'face 'completions-annotations)
                       'line-num line-num)
           formatted-candidates)

     finally return (list default-candidate
                          (nreverse formatted-candidates)))
    ;; ...
  #+end_src

  The limitations of =cl-loop='s =when= clause encourages relying on Lisp
  expressions rather than clauses for processing.  To use those Lisp
  expressions, one must declare more variables with the =with= clause to ensure
  that those variables are locally scoped.

  Here is how it could be done with =loopy=:

  #+begin_src emacs-lisp
    ;; ...
    (loopy
     (with (buffer-text-lines (split-string (buffer-string) "\n"))
           (number-format (concat "L%0"
                                  (number-to-string
                                   (length (number-to-string
                                            (length buffer-text-lines))))
                                  "d: ")))
     (list line-text buffer-text-lines)
     (expr line-num (line-number-at-pos (point-min) t)
           (1+ line-num))
     (unless (string-empty-p line-text)
       (push-into formatted-candidates
                  (propertize line-text
                              'selectrum-candidate-display-prefix
                              (propertize (format number-format line-num)
                                          'face 'completions-annotations)
                              'line-num line-num))
       ;; There are a few different ways that you could express
       ;; this.
       (when (null default-candidate)
         (expr prev-dist +1.0e+INF dist-to-default-cand)
         (expr dist-to-default-cand (abs (- current-line-number
                                            line-num)))
         (when (> dist-to-default-cand prev-dist)
           (expr default-candidate (cl-second formatted-candidates)))))
     (finally-return default-candidate (nreverse formatted-candidates)))
    ;; ...
  #+end_src

  We can see that most of the loop commands are easily grouped under the
  =unless= command.  This allows for less noise, as we do not need to declare
  variables or fall back to using more Lisp expressions.

  Another good example is the command =selectrum-outline= from the same page.
  This command is similar to =selectrum-swiper=, but has a slightly more
  complicated processing portion.

  The code loops through each line in the buffer, searching for lines that match
  a pre-determined regular expression.  The match data is used to determine the
  heading level (top level, second level, etc.) and the actual heading text.
  The loop produces formatted candidates by prepending this heading text with
  the text of parent headings, as determined by the heading level.  At the same
  time, the loop selects the current heading as the default candidate.

  Instead of using =cl-loop=, this command is written in conventional Emacs
  Lisp.

  #+begin_src emacs-lisp
    ;; ...
    (let (;; Get the basic information of each heading in the accessible
          ;; portion of the buffer.
          (buffer-lines (split-string (buffer-string) "\n"))
          (line-number 0)
          (line-number-format)

          ;; Finding the default heading
          (default-heading)
          (current-line-number (line-number-at-pos (point)))

          ;; Keeping track of the tree.
          (backwards-prefix-list)
          (prev-heading-text)
          (prev-heading-level)

          ;; Backwards result of the ‘dolist'. Will ‘nreverse’.
          (formatted-headings))

      (setq line-number-format
            (concat "L%0"
                    (number-to-string
                     (length (number-to-string (length buffer-lines))))
                    "d: "))

      (save-match-data
        (dolist (text-line buffer-lines)
          ;; Increment line number when moving to next.
          (cl-incf line-number)
          (when (string-match heading-regexp text-line)
            (let ((heading-text (match-string-no-properties 2 text-line))
                  (heading-level
                   (length (match-string-no-properties 1 text-line))))

              ;; Make sure this has a valid value when we first compare.  The
              ;; first comparison should be equal, so that nothing is
              ;; needlessly added to the prefix list, which causes bad
              ;; formatting.
              (unless prev-heading-level
                (setq prev-heading-level heading-level))

              ;; Decide whether to update the prefix list and the previous
              ;; heading level.
              (cond
               ;; If we've moved to a greater level (further down the tree),
               ;; add the previous heading to the heading prefix list so
               ;; that we can prepend it to the current heading when
               ;; formatting.
               ((> heading-level prev-heading-level)
                (setq backwards-prefix-list (cons prev-heading-text
                                                  backwards-prefix-list)
                      prev-heading-level heading-level))
               ;; Otherwise, if we've moved to a lower level (higher up the
               ;; tree), and need to remove the most recently added prefix
               ;; from the list (i.e., go from '(c b a) back to '(b a)).
               ((< heading-level prev-heading-level)
                (setq backwards-prefix-list (last backwards-prefix-list
                                                  heading-level)
                      prev-heading-level heading-level)))

              ;; Regardless of what happens, update the previous heading text.
              (setq prev-heading-text heading-text)

              ;; Decide whether the previous formatted heading was the
              ;; default.
              (when (and (null default-heading)
                         (> line-number current-line-number))
                (setq default-heading (cl-first formatted-headings)))

              ;; Finally, add to list of formatted headings.
              ;; Create heading of form "L#: a/b/c" as:
              ;; - having a text property holding the line number
              ;; - prepended with a formatted line number,
              ;;   with the face ‘completions-annotations’.
              (push (propertize
                     (concat (string-join (reverse backwards-prefix-list) "/")
                             (and backwards-prefix-list "/")
                             heading-text)
                     'line-number line-number
                     'selectrum-candidate-display-prefix
                     (propertize
                      (format line-number-format line-number)
                      'face 'completions-annotations))
                    formatted-headings)))))
      ;; ...
      )
  #+end_src

  Here is a version in =loopy= which is more of a straight translation than a
  re-working:

  #+begin_src emacs-lisp
    ;; ...
    (loopy
     (with (buffer-lines (split-string (buffer-string) "\n"))
           (line-number-format
            (concat "L%0"
                    (number-to-string
                     (length (number-to-string (length buffer-lines))))
                    "d: ")))
     (expr line-number 1 (1+ line-number))
     (list text-line buffer-lines)
     (when (string-match heading-regexp text-line)
       (expr heading-text
             (match-string-no-properties 2 text-line))
       (expr heading-level
             (length (match-string-no-properties 1 text-line)))

       ;; Decide whether to update the prefix list and the previous
       ;; heading level.
       (cond
        ;; If we've moved to a greater level (further down the tree),
        ;; add the previous heading to the heading prefix list so that
        ;; we can prepend it to the current heading when formatting.
        ((> heading-level (or prev-heading-level heading-level))

         (push-into backwards-prefix-list prev-heading-text)
         (expr prev-heading-level heading-level))
        ;; Otherwise, if we've moved to a lower level (higher up the
        ;; tree), and need to remove the most recently added prefix
        ;; from the list (i.e., go from '(c b a) back to '(b a)).
        ((< heading-level (or prev-heading-level heading-level))
         (expr backwards-prefix-list (last backwards-prefix-list
                                           heading-level))
         (expr prev-heading-level heading-level)))

       ;; Regardless of what happens, update the previous heading
       ;; text.
       (expr prev-heading-text heading-text)

       ;; Decide whether the previous formatted heading was the
       ;; default.
       (when (and (null default-heading)
                  (> line-number current-line-number))
         (expr default-heading (car formatted-headings)))

       ;; Finally, add to list of formatted headings.
       ;; Create heading of form "L#: a/b/c" as:
       ;; - having a text property holding the line number
       ;; - prepended with a formatted line number,
       ;;   with the face ‘completions-annotations’.
       (push-into
        formatted-headings
        (propertize
         (concat (string-join
                  (reverse backwards-prefix-list) "/")
                 (and backwards-prefix-list "/")
                 heading-text)
         'line-number line-number
         'selectrum-candidate-display-prefix
         (propertize (format line-number-format line-number)
                     'face 'completions-annotations))))
     (finally-return default-heading (nreverse formatted-headings)))
    ;; ...
  #+end_src

  In my opinion, the =loopy= version is a bit cleaner.  Even when following the
  same flow of logic, you still get the benefit of less typing with no loss in
  clarity.

  If one were writing code like this often (say, in a library), then the loop
  body could be simplified even further with custom commands
  ([[#adding-custom-commands]]).

* Macro Argument and Loop Command Index
  :PROPERTIES:
  :INDEX: fn
  :END:

* Variable Index
  :PROPERTIES:
  :INDEX: vr
  :END:

* Concept Index
  :PROPERTIES:
  :INDEX: cp
  :END:

* Footnotes

[fn:sel-wiki]
[[https://github.com/raxod502/selectrum/wiki/Useful-Commands#swiper-like-jumping-to-matching-lines]]

[fn:iter] https://common-lisp.net/project/iterate/
