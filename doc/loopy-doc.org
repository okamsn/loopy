#+title: Loopy: A Looping and Iteration Macro
#+author: Earl Hyatt
#+export_file_name: loopy

# Make sure to export all headings as such.  Otherwise, some links to
# sub-headings won’t work.
#+options: H:6
# Some parsers require this option to export footnotes.
#+options: f:t

# Texinfo settings.
#+TEXINFO_FILENAME: loopy.info
#+TEXINFO_DIR_CATEGORY: Emacs
#+TEXINFO_DIR_TITLE: Loopy: (loopy)
#+TEXINFO_DIR_DESC: A looping and iteration macro.

#+MACRO: dfn @@texinfo:@dfn{$1}@@
#+MACRO: kbd @@texinfo:@kbd{$1}@@
#+MACRO: file @@texinfo:@file{$1}@@
#+MACRO: var @@texinfo:@var{$1}@@

#+begin_export html
NOTE: This file is meant for viewing in Org mode or for exporting to Texinfo.
Features might not work in other formats (e.g., Info links in HTML).
#+end_export

~loopy~ is a macro meant for iterating and looping.  It is similar in usage to
~cl-loop~ ([[info:cl#Loop Facility]]) but uses parenthesized expressions rather than
keyword clauses.

For most cases, ~loopy~ is a featureful replacement for ~cl-loop~ and
complementary to Emacs's built-in looping and mapping features (such as the
libraries =seq= ([[info:elisp#Sequence Functions]]) and =cl-lib= ([[info:cl]])).


-----

# This auto-generated by toc-org.
* Table of Contents                                                :TOC:noexport:
- [[#introduction][Introduction]]
- [[#basic-concepts][Basic Concepts]]
- [[#special-macro-arguments][Special Macro Arguments]]
- [[#loop-commands][Loop Commands]]
  - [[#generic-evaluation][Generic Evaluation]]
  - [[#iteration][Iteration]]
    - [[#generic-iteration][Generic Iteration]]
    - [[#numeric-iteration][Numeric Iteration]]
    - [[#sequence-iteration][Sequence Iteration]]
    - [[#sequence-index-iteration][Sequence Index Iteration]]
    - [[#sequence-reference-iteration][Sequence Reference Iteration]]
  - [[#accumulation][Accumulation]]
    -  [[#accumulation-commands][Accumulation Commands]]
    - [[#stack-based-accumulations][Stack-Based Accumulations]]
    -  [[#optimizing-accumulations][Optimizing Accumulations]]
  - [[#boolean][Boolean]]
  - [[#control-flow][Control Flow]]
    - [[#conditionals][Conditionals]]
    - [[#skipping-cycles][Skipping Cycles]]
    - [[#early-exit][Early Exit]]
  - [[#sub-loops][Sub-Loops]]
- [[#special-variables][Special Variables]]
- [[#destructuring-macros][Destructuring Macros]]
- [[#the-loopy-iter-macro][The ~loopy-iter~ Macro]]
- [[#using-flags][Using Flags]]
- [[#custom-aliases][Custom Aliases]]
- [[#custom-commands][Custom Commands]]
  - [[#background-info][Background Info]]
  - [[#hello-world][Hello World]]
  - [[#an-always-command][An ~always~ Command]]
  - [[#finding-more-examples][Finding More Examples]]
- [[#comparing-to-cl-loop][Comparing to ~cl-loop~]]
- [[#translating-to-and-from-cl-loop][Translating to and from =cl-loop=]]
  - [[#for-clauses][For Clauses]]
  - [[#iteration-clauses][Iteration Clauses]]
  - [[#accumulation-clauses][Accumulation Clauses]]
  - [[#other-clauses][Other Clauses]]
-  [[#real-world-examples][Real-World Examples]]
- [[#macro-argument-and-loop-command-index][Macro Argument and Loop Command Index]]
- [[#variable-index][Variable Index]]
- [[#concept-index][Concept Index]]
- [[#footnotes][Footnotes]]

* Introduction
  :PROPERTIES:
  :DESCRIPTION: A short overview.
  :END:

  The ~loopy~ macro is used to generate code for a loop, similar to ~cl-loop~.
  Unlike ~cl-loop~, ~loopy~ uses parenthesized expressions instead of "clauses".

  #+begin_src emacs-lisp
    ;; A simple usage of `cl-loop':
    (cl-loop for i from 1 to 10
             if (cl-evenp i) collect i into evens
             else collect i into odds
             end ; This `end' keyword is optional here.
             finally return (list odds evens))

    ;; How it could be done using `loopy':
    (loopy (numbers i 1 10)
           (if (cl-evenp i)
               (collect evens i)
             (collect odds i))
           (finally-return odds evens))
  #+end_src

  ~loopy~ supports destructuring for iteration commands like =list= and
  accumulation commands like =sum= or =collect=.

  #+begin_src emacs-lisp
    ;; Summing the nth elements of arrays:
    ;; => (8 10 12 14 16 18)
    (loopy (list (list-elem1 list-elem2)
                 '(([1 2 3] [4 5 6])
                   ([7 8 9] [10 11 12])))
           (sum [sum1 sum2 sum3] list-elem1)
           (sum [sum4 sum5 sum6] list-elem2)
           (finally-return sum1 sum2 sum3 sum4 sum5 sum6))

    ;; Or, more simply:
    ;; => (8 10 12 14 16 18)
    (loopy (list list-elem '(([1 2 3] [4 5 6])
                             ([7 8 9] [10 11 12])))
           (sum ([sum1 sum2 sum3] [sum4 sum5 sum6])
                list-elem)
           (finally-return sum1 sum2 sum3 sum4 sum5 sum6))

    ;; Separate the elements of sub-list:
    ;; => ((1 3) (2 4))
    (loopy (list i '((1 2) (3 4)))
           (collect (elem1 elem2) i)
           (finally-return elem1 elem2))
  #+end_src

  The ~loopy~ macro is configurable and extensible.  In addition to writing
  one's own "loop commands" (such as =list= in the example below), by using
  "flags", one can choose whether to instead use ~pcase-let~, ~seq-let~, or even
  the Dash library for destructuring.

  #+begin_src emacs-lisp
    ;; Use `pcase' to destructure array elements:
    ;; => ((1 2 3 4) (10 12 14) (11 13 15))
    (loopy (flag pcase)
           (array (or `(,car . ,cdr) digit)
                  [1 (10 . 11) 2 (12 . 13) 3 4 (14 . 15)])
           (if digit
               (collect digits digit)
             (collect cars car)
             (collect cdrs cdr))
           (finally-return digits cars cdrs))

    ;; Using the default destructuring:
    ;; => ((1 2 3 4) (10 12 14) (11 13 15))
    (loopy (array elem [1 (10 . 11) 2 (12 . 13) 3 4 (14 . 15)])
           (if (numberp elem)
               (collect digits elem)
             (collect (cars . cdrs) elem))
           (finally-return digits cars cdrs))
  #+end_src

  Variables like ~cars~, ~cdrs~, and ~digits~ in the example above are
  automatically ~let~-bound so as to not affect code outside of the loop.

  ~loopy~ has arguments for binding (or not binding) variables, executing code
  before/after the loop, executing code only if the loop completes, and for
  setting the macro's return value (default ~nil~).  This is in addition to the
  looping features themselves.

  All of this makes ~loopy~ a useful and convenient choice for looping and
  iteration.

  That being said, Loopy is not yet feature complete.  Please request features
  or report problems in this project’s [[https://github.com/okamsn/loopy/issues][issues tracker]].  While most cases are
  covered, full feature parity with some of the more niche uses of ~cl-loop~ is
  still being worked on.

* Basic Concepts
  :PROPERTIES:
  :CUSTOM_ID: basic-concepts
  :DESCRIPTION: Basic information about `loopy' and its loops.
  :END:

  Except for an optional loop name, all arguments of the ~loopy~ macro are
  parenthesized expressions.  These expressions can, for example, assign
  variables local to the loop, add code that runs before/after the loop, and/or
  set the ultimate return value of the macro.

  For convenience and clarity, expressions that generate code in the loop body
  are called "loop commands" ([[#loop-commands][Loop Commands]]).  Expressions that generate code
  around the loop are called "special macro arguments" or just "macro arguments"
  as opposed to "loop commands" ([[#macro-arguments][Special Macro Arguments]]).

  "Loop commands" are the main feature of the ~loopy~ macro, such as the command
  =list= in the expression =(list i '(1 2 3))=.  A command inserts code into the
  loop body, but can also perform additional setup like initializing variables.
  Many commands set a condition for ending the loop.  In the case of =list=, it
  iterates through the elements of a list, the variable ~i~ to each element.
  After iterating through all elements, the loop is forced to end.

  The loop ends when any condition required by a loop command evaluates to
  ~nil~.  If no conditions are needed, the loop runs infinitely until a =return=
  or =return-from= command is reached ([[#exiting-the-loop-early][Exiting the Loop Early]]).

  Except when using accumulating loop commands ([[#accumulation-commands][Accumulation Commands]]), return
  values must be stated explicitly, either as an early return in the loop body
  via the =return= or =return-from= commands, or as part of the =finally-return=
  macro argument.  ~nil~ is returned by default.

  The macro is configurable.  One can add custom commands ([[#adding-custom-commands][Custom Commands]]), add
  custom command aliases ([[#custom-aliases][Custom Aliases]]), and specify macro options for a
  particular loop ([[#flags][Using Flags]]).  Each of these ideas is explained in detail
  later in this document.

  #+cindex: lexical binding
  #+ATTR_TEXINFO: :tag Note
  #+begin_quote
  This macro uses functional paradigms for some behavior, and requires that
  lexical binding be enabled ([[info:elisp#Using Lexical Binding]]).

  Typically, this is done by including ~-*- lexical-binding: t; -*-~
  in a comment in the first line of an Emacs Lisp file, such as your =init.el=.
  #+end_quote


* Special Macro Arguments
  :PROPERTIES:
  :CUSTOM_ID: macro-arguments
  :DESCRIPTION: Creating the environment of the loop.
  :END:

  #+cindex: special macro argument
  There are only a few special macro arguments. One, an unquoted symbol, is
  taken as the loop's name. The others, listed below, are parenthesized
  expressions that begin with a keyword or one of their aliases.

  If a macro argument does not match one of these special few, ~loopy~ will
  attempt to interpret it as a loop command, and signal an error if that fails.

  These special macro arguments are always processed before loop commands,
  regardless of the order of the arguments passed to ~loopy~.

  #+findex: with, let*
  - =with=, =let*=, =init= :: Declare variables before the loop, in order.  This
    can also be used to initialize variables referenced by loop commands.

    #+begin_src emacs-lisp
      ;; => (4 5 6)
      (loopy
       (with (a 1)          ; Set `a' to 1.
             (b (1+ a)))    ; Set `b' to 1+1=2.
       (list i '(1 2 3))    ; Bind `i' to elements of the list.
       (collect (+ i a b))) ; Collect sum of `a', `b', and each `i' into a list.

      ;; => 16
      (loopy
       (let* (my-sum 10))       ; Bind `my-sum' to 10.
       (list i '(1 2 3))        ; Bind `i' to elements of the list.
       (sum my-sum i)           ; Set `my-sum' to `i' + `my-sum'.
       (finally-return my-sum)) ; Return the value of `my-sum'.
    #+end_src

  #+findex: without, no-init
  - =without=, =no-with=, =no-init= :: Variables that ~loopy~ should not try to
    initialize.  ~loopy~ tries to initialize all of the variables that it uses
    in a ~let~-like form, but that isn’t always desired.

    #+begin_src emacs-lisp
      ;; Without `without', `loopy' would try to initialize `a' to nil, which would
      ;; overwrite the value of 5 above.

      (let ((a 5))
        (loopy (without a)        ; Don't initialize `a'.
               (until (zerop a))  ; Leave loop when `a' equals 0.
               (collect a)        ; Collect the value of `a' into a list.
               (set a (1- a))))   ; Set `a' to the value of `(1- a)'.

      (let ((a 5))
        (loopy (no-init a)
               (while (not (zerop a)))
               (collect a)
               (set a (1- a))))
    #+end_src

  #+findex: before-do, before
  - =before-do=, =before=, =initially-do=, =initially= :: Run Lisp expressions
    before the loop starts, after variables are initialized.

    #+begin_src emacs-lisp
      ;; = > (6 7 8)
      (loopy (with (a 1) (b 2))          ; Set `a' to 1 and `b' to 2.
             (before-do (setq a (1+ a))  ; Add 1 to `a'.
                        (setq b (1+ b))) ; Add 1 to `b'.
             (list i '(1 2 3))           ; Set `i' to each element in the list.
             (collect (+ i a b)))        ; Collect each sum into a list.

      ;; => (1 2 3)
      (loopy (with (a 1))
             ;; Message before the loop starts:
             (initially (message "Starting loop..."))
             (list i '(1 2 3))
             (collect i))
    #+end_src

  #+findex: after-do, after, else-do, else
  - =after-do=, =after=, =else-do=, =else= :: Run Lisp expressions after the
    loop successfully completes.  This is similar to Python’s ~else~ statement
    following a ~for~ or ~while~ loop.

    #+begin_src emacs-lisp
      ;; Messages that no odd number was found:
      ;; => nil
      (loopy (list i '(2 4 6 8))
             (when (cl-oddp i)
               (do (message "Odd number found."))
               (return t))                  ; Make the loop return `t'.
             (after-do
              (message "No odd number found.")
              ;; The macro already return `nil' by default,
              ;; but one can still use `cl-return' to be more explicit.
              (cl-return nil)))

      ;; Messages that an odd number was found:
      ;; => t
      (loopy (list i '(2 4 5 8))
             (when (cl-oddp i)
               (do (message "Odd number found."))
               (return t))
             (else (message "No odd number found.")))
    #+end_src

  #+findex: finally-do, finally
  - =finally-do=, =finally= :: Always run Lisp expressions after the loop exits.
    These expressions _do not_ affect the final return value of the loop.

    #+begin_src emacs-lisp
      (loopy (list i '(1 2 3))
             (when (cl-oddp i) (break))
             (after-do (message "This not messaged."))
             (finally-do (message "This always messaged.")))

      ;; Messages that the final value of `i' is 4 and returns `i':
      ;; => 4
      (loopy (list i '(1 2 3 4 5))
             (when (> i 3) (return i))
             (finally-do
              (message "The final value of `i' is: %d" i)
              ;; This expression does not affect the loop's return value:
              (+ i 7)))
    #+end_src

  #+findex: finally-return
  - =finally-return= :: Return a value, regardless of how the loop completes.
    These arguments override any explicit return values given in commands like
    =return= and =return-from=, as well as any implicit return values that can
    be created by accumulation commands.

    Specifying multiple values is the same as returning a list of those values,
    which is useful when using features like ~seq-let~, ~pcase-let~, and
    ~cl-destructuring-bind~.

    #+begin_src emacs-lisp
      ;; => "This string always returned."
      (loopy (list i '(1 2 3))
             (when (cl-oddp i)
               (return "This return value is over-ridden."))
             (finally-return "This string always returned."))

      ;; To be clear, the below code would be better expressed as
      ;; `(loopy (return 1 2 3))'.  In the below example,
      ;; the command `leave' is used to avoid an infinite loop.
      ;;
      ;; => (1 2 3)
      (loopy (leave)  ; Immediately leave the loop.
             (finally-return 1 2 3))
    #+end_src

  #+findex: finally-protect, finally-protected
  - =finally-protect=, =finally-protected= :: Wrap the loop in ~unwind-protect~
    (not to be confused with ~condition-case~).  The arguments to this special
    macro argument (which are Lisp expressions) can access the variables used by
    the loop.

    Signaling an error will prevent the loop from returning a value.  This
    special macro argument does not prevent that error from being signaled, and
    is only meant to help avoid lingering effects that might arise from
    unplanned stops of the loop's execution.

    #+begin_src emacs-lisp
      ;; Prints out the following, then continues signalling the error:
      ;;
      ;; Example var is: 1
      ;; Last used element in list is: 4
      ;; Then current value of ‘my-collection’: (1 2 3 4)
      (loopy (with (example-var 1))
             (list i '(1 2 3 4 5))
             (collect my-collection i)
             (when (> i 3)
               (do (signal 'some-error (list i))))
             (finally-protect
              (message "Example var is: %d" example-var)
              (message "Last used element in list is: %s" i)
              (message "Then current value of `my-collection': %s"
                       my-collection)))
    #+end_src

  #+findex: flag, flags
  - =flag=, =flags= :: Options that change the behavior of ~loopy~ ([[#flags]]).
    For example, one can opt to use a different destructuring system, such as
    what is provided by the Dash library.  See that linked section for more
    information.

    #+begin_src emacs-lisp
      ;; Use Dash for destructuring:
      ;;
      ;; (((1 2) (3 4)) (1 3) (2 4))
      (loopy (flag dash)
             (list (whole &as a b) '((1 2) (3 4)))
             (collect wholes whole)
             (collect as a)
             (collect bs b)
             (finally-return wholes as bs))

      ;; Use Seq for destructuring:
      ;;
      ;; => (1 [2 3])
      (loopy (flag seq)
             (with ([a &rest b] [1 2 3]))
             (return a b))

      ;; Automatically split accumulations into separate variables:
      ;;
      ;; => ((1 3) (2 4))
      (loopy (flag split)
             (list (i j) '((1 2) (3 4)))
             (collect i)
             (collect j))
    #+end_src

  #+findex: accum-opt
  - =accum-opt=, =opt-accum= :: Accumulation variables whose use should be
    optimized ([[#optimized-accums]]).  ~loopy~ produces efficient code without too
    many assumptions, but this special macro argument allows for more control.

  #+findex: wrap
  - =wrap= :: A list of forms in which to wrap the loop itself (i.e., not
    =before-do=, =after-do=, or anything else).  Each form can be either a list
    or a symbol.  If a list, the loop is inserted into the end of the list.  If
    a symbol, it is first converted to a list of 1 element before inserting the
    loop at the end of the list.  This special macro argument is similar in use
    to the Emacs Lisp macro ~thread-last~, except that forms listed first are
    applied last, as in normal Lisp code.

    The main difference between using this macro argument instead of just
    writing the function calls normally is that these forms can access variables
    initialized by the macro and that they occur after the code in =before-do=
    is run.

    #+begin_src emacs-lisp
      (loopy (wrap (let ((a 1)))
                   save-match-data)
             ...)

      ;; Similar to
      (let ((a 1))
        (save-match-data
          (loopy ...)))

      ;; => 6
      (loopy (with (a 1))
             (before-do (cl-incf a 2))
             (wrap (progn (setq a (* 2 a))))
             (return a))
    #+end_src

  As stated above, all other expressions will be considered loop commands
  ([[#loop-commands][Loop Commands]]).


  #+ATTR_TEXINFO: :tag Note
  #+BEGIN_QUOTE
  For convenience, the ~while~-loop that ~loopy~ creates is wrapped by a
  ~cl-block~.  Naming the loop names this block, which is created /after/
  initializing variables.

  The two special macro arguments =before-do= and =after-do= (and their aliases)
  also occur within this ~cl-block~, before and after the loop, respectively.
  This has 2 consequences:

  1. Using ~cl-return~ in =before-do= will prevent the both loop and =after-do=
     code from running.

  2. Using ~cl-return~ or an early exit command ([[#exiting-the-loop-early][Early Exit]]) in the loop will
     prevent the =after-do= code from running.  For this reason, =after-do= is
     run if and only if the loop completes successfully, hence the alias
     =else-do= and the similarity to Python's ~else~ statement when used with
     loops.

  These three sections (=before-do=, =after-do=, and the ~while~-loop itself)
  are the only structures that occur within the ~cl-block~.  Using ~cl-return~
  in =before-do=, for example, will not stop code in =finally-do= from running
  or values listed in =finally-return= from being returned.
  #+END_QUOTE

* Loop Commands
  :PROPERTIES:
  :CUSTOM_ID: loop-commands
  :DESCRIPTION: The main features of `loopy'.
  :END:

  #+cindex: loop command
  If a macro argument does not match one of the previously listed special macro
  arguments ([[#macro-arguments][Special Macro Arguments]]), ~loopy~ will attempt to treat it as a
  loop command.  Loop commands are only valid as a top-level argument to the
  macro, or inside another loop command.

  Therefore, these macro calls are valid:

  #+BEGIN_SRC emacs-lisp
    (loopy (list i '(1 2 3))
           (collect coll i)
           ;; Special macro argument:
           (finally-return coll))

    ;; Implicit accumulation variable and implicit return value:
    (loopy (list i '(1 2 3))
           (collect i))
  #+END_SRC

  and this is not:

  #+BEGIN_SRC emacs-lisp
    (loopy (with (list i '(1 2 3)))
           (finally-return (collect coll i)))
  #+END_SRC

  Trying to use loop commands in places where they don't belong will result in
  errors when the code is evaluated.

  You should keep in mind that commands are evaluated in order.  This means that
  attempting to do something like the below example might not do what you
  expect, as =i= is assigned a value from the list after collecting =i= into
  =coll=.

  #+caption: An example of how loop commands are evaluated in order.
  #+BEGIN_SRC emacs-lisp
    ;; => (nil 1 2)
    (loopy (collect coll i)
           (list i '(1 2 3))
           (finally-return coll))
  #+END_SRC

  For convenience and understanding, the same command might have multiple names,
  called {{{dfn(aliases)}}}.  For example, the command =set= has an alias
  =expr=, because =set= is used to /set/ a variable to the value of an
  /expression/.  Similary, the =array= command has the alias =string=, because
  the =array= command can be used to iterate through the elements of an array or
  string[fn:1].  You can define custom aliases using the macro ~loopy-defalias~
  ([[#custom-aliases][Custom Aliases]]).

  Some commands take optional keyword arguments.  For example, the command
  =list= can take a function argument following the keyword =:by=, which affects
  how that iterates through the elements in the list.

  For simplicity, the commands are described using the following notation:

  - If a command has multiple names, the names are separated by a vertical
    bar, such as in =set|expr=.
  - =VAR= is an unquoted symbol that will be used as a variable name, such as
    =i= in =(list i my-list)=.
  - =FUNC= is a quoted Lisp function name, such as ~#'my-func~ or ~'my-func~, a
    variable whose value is a function, or a ~lambda~ expression.
  - =NAME= is an unquoted name of a loop (or, more accurately, of a
    =cl-block=).
  - =EXPR= is a single Lisp expression, such as =(+ 1 2)=, ='(1 2 3)=,
    =my-var=, or =(some-function my-var)=.  =EXPRS= means multiple expressions.
    Really, we are concerned with the value of the expression, not the
    expression itself.
  - =CMD= is a loop command, as opposed to a normal Lisp expression.
    =(list i '(1 2 3))=, =(cycle 5)=, and =(return-from outer-loop 7)=
    are examples of loop commands.  =CMDS= means multiple commands.
  - Optional arguments are surround by brackets.  =[EXPR]= is an optional
    expression, and =[CMD]= is an optional command.  By extension,
    =[EXPRS]= is equivalent to =[EXPR [EXPR [...]]]=, and =[CMDS]= to
    =[CMD [CMD [...]]]=.
  - Optional keyword arguments are shown as =&key key1 key2 ...=, where =key1=,
    =key2=, and so on are the literal keywords.  Just like in normal Lisp
    functions, keywords must be prefixed by a colon (":").  For example, the
    iteration command =nums= has a keyword argument =by=, which can be given a
    value using =:by SOME-EXPRESSION=.


  Generally, =VAR= is initialized to ~nil~, but not always.  This document
  tries to note when that is not the case.

  #+cindex: variable destructuring
  Similar to features like ~seq-let~, ~cl-destructuring-bind~, and ~pcase-let~,
  ~loopy~ is capable of destructuring values when assigning values to variables.
  Unlike in ~cl-loop~, destructuring can also be used with accumulation
  commands.

  #+begin_src emacs-lisp
    ;; => '((1 3) (2 4))
    (loopy (list (car . cdr) '((1 . 2) (3 . 4)))
           (collect cars car)
           (collect cdrs cdr)
           (finally-return cars cdrs))

    ;; Using `cl-loop':
    (cl-loop for (car . cdr) in '((1 . 2) (3 . 4))
             collect car into cars
             collect cdr into cdrs
             finally return (list cars cdrs))

    ;; Not possible in `cl-loop':
    ;; => '((1 3) (2 4))
    (loopy (list i '((1 . 2) (3 . 4)))
           (collect (cars . cdrs) i)
           (finally-return cars cdrs))
  #+end_src

  You can use destructured assignment by passing an unquoted sequence as the
  =VAR= argument of a loop command.  To destructure lists, use a list.  To
  destructure arrays (including strings and vectors), use a vector.  This
  sequence of symbols can be shorter than the destructured sequence, /but not
  longer/.  If shorter, the unassigned elements of the list are simply ignored.

  An element in the sequence =VAR= can be one of the following:

  - A positional variable which will be bound to the corresponding element in
    the sequence.  These variables can be recursive.

    #+begin_src emacs-lisp
      ;; ((1 2 3) (4 5 6))
      (loopy (list [i (j k)] '([1 (2 3)] [4 (5 6)]))
             (collect (list i j k)))
    #+end_src

  - =&whole=: If =&whole= is the first element in the sequence, then the second
    element names a variable that holds the entire value of what is
    destructured.

    #+begin_src emacs-lisp
      ;; See that the variable `whole' holds the value of the entire
      ;; list element:
      ;; => (((1 2 3) 1 2 3)
      ;;     ((4 5 6) 4 5 6))
      (loopy (list (&whole whole i j k)  '((1 2 3) (4 5 6)))
             (collect (list whole i j k)))
    #+end_src

  - =&rest=: A variable named after =&rest= contains the remaining elements of
    the destructured value.  When destructuring lists, one can alternatively use
    dotted notation.  These variables can be recursive.

    #+begin_src emacs-lisp
      ;; => ((1 [2 3]) (4 [5 6]))
      (loopy (list [i &rest j] '([1 2 3] [4 5 6]))
             (collect (list i j)))

      ;; => ((1 (2 3)) (4 (5 6)))
      (loopy (list (i . j) '((1 2 3) (4 5 6)))
             (collect (list i j)))

      ;; Works the same as above:
      (loopy (list (i &rest j) '((1 2 3) (4 5 6)))
             (collect (list i j)))

      ;; => ((1 2 3) (4 5 6))
      (loopy (list (i . [j k]) '((1 . [2 3]) (4 . [5 6])))
             (collect (list i j k)))

      ;; Works the same as above:
      (loopy (list (i &rest [j k]) '((1 . [2 3]) (4 . [5 6])))
             (collect (list i j k)))
    #+end_src

  - =&key=: Variables named after =&key= are transformed into keys whose values
    will be sought using ~plist-get~.  Optionally, these variables can be a list
    of 2 elements: (1) the variable and (2) a default value if that key isn't
    found.
    - Currently, only lists support this destructuring.
    - Keys are sought in values after those bound to positional variables, which
      can be the same values to the variable named by =&rest= when both are
      used.
    - =&key= and =&rest= can be used in any order, but =&key= must come before
      the dot in dotted lists.

    #+begin_src emacs-lisp
      ;; => ((1 2) (4 5))
      (loopy (list (&key a b) '((:b 2 :c 3 :a 1)
                                (:a 4 :b 5 :c 6)))
             (collect (list a b)))

      ;; Giving a default value:
      ;; Note that `nil' is not the same as a missing value.
      ;; => ((1 2 nil 25) (4 5 24 25))
      (loopy (list (&key a b (c 24) (d 25)) '((:b 2 :c nil :a 1)
                                              (:a 4 :b 5)))
             (collect (list a b c d)))

      ;; Keys are only sought after positional variables:
      ;; => ((1 2 :k1 'ignored 3))
      (loopy (array (a b c d &key k1) [(1 2 :k1 'ignored :k1 3)])
             (collect (list a b c d k1)))

      ;; If `&rest' is used, keys are sought only in that variable:
      ;; => ((1 (:k1 3) 3))
      (loopy (array (a &rest b &key k1) [(1 :k1 3)])
             (collect (list a b k1)))

      ;; The below two examples work the same as the above:

      (loopy (array (a &key k1 &rest b) [(1 :k1 3)])
             (collect (list a b k1)))

      (loopy (array (a &key k1 . b) [(1 :k1 3)])
             (collect (list a b k1)))
    #+end_src


  Alternative destructuring systems can be used via flags ([[#flags]]).  For more
  flexible pattern matching, see the flag =pcase=.  For more kinds of key-value
  destructuring, see the flag =dash= provided by the package =loopy-dash=.

  Most commands that assign variables can use destructuring, but not all kinds
  of destructuring make sense in all situations.  Accumulation commands
  ([[#accumulation-commands]]) and commands iterating through ~setf~-able places in
  a sequence ([[#sequence-reference-iteration]]) have their own kinds of
  destructuring.  They are explained more in their respective sections.

** Generic Evaluation
   :PROPERTIES:
   :DESCRIPTION: Setting variables, evaluating expressions, etc.
   :CUSTOM_ID: commands-for-generic-evaluation
   :END:

   #+findex: do
   - =(do EXPRS)= :: Evaluate multiple Lisp expressions, like a =progn=.

     You cannot include arbitrary code in the loop body.  Trying to do so will
     result in errors, as the macro will attempt to interpret such code as a
     command.

     #+BEGIN_SRC emacs-lisp
       (loopy (list i '(1 2 3))
              (do (message "%d" i)))
     #+END_SRC

   #+findex: set, expr, exprs
   - =(set|expr|exprs VAR [EXPRS] &key init)= :: Bind =VAR= to each =EXPR= in
     order.  Once the last =EXPR= is reached, it is used repeatedly for the rest
     of the loop.  With no =EXPR=, =VAR= is repeatedly bound to ~nil~.

     If =INIT= is provided, use that as the initial value of =VAR=.  This could
     also be achieved by specifying a value using the =with= special macro
     argument.  When destructuring, each variable is initialized to =INIT=, not
     a destructured part of =INIT=.

     #+ATTR_TEXINFO: :tag Note
     #+begin_quote
     =set= does /not/ behave the same as ~setq~ in all situations.

     While =set= can take multiple arguments, it only assigns the value of one
     expression to one variable during each iteration of the loop (unless using
     destructuring).  It cannot take pairs of variables and values in the same
     way that ~setq~ does.

     Furthermore, variables assigned by =set= (and other commands) are by
     default ~let~-bound around the loop and generally initialized to ~nil~.
     This means that doing =(set VAR EXPR)= will not, by default, affect
     variables outside of the loop in the same way that using =(do (setq VAR
     EXPR))= would.
     #+end_quote

     #+BEGIN_SRC emacs-lisp
       ;; => '(1 2 3 3 3)
       (loopy (cycle 5)
              (set i 1 2 3)
              (collect coll i)
              (finally-return coll))

       ;; => '(0 1 2 3 4)
       (loopy (cycle 5)
              (set i 0 (1+ i))
              (collect coll i)
              (finally-return coll))

       ;; Note that `i' is initialized to 0, and set to 1 in
       ;; the middle of the first cycle of the loop.
       ;;
       ;; => ((0 1 2) (1 2 3))
       (loopy (cycle 3)
              (collect befores i)
              (set i 1 (1+ i) :init 0)
              (collect afters i)
              (finally-return befores afters))

       ;; Note that using `with' has a similar effect.
       ;; => (0 1 2)
       (loopy (with (i 0))
              (cycle 3)
              (collect i)
              (set i 1 (1+ i)))
     #+END_SRC

   #+findex: group
   - =(group|command-do [CMDS])= :: Evaluate multiple loop commands, as if in a
     =progn=.  This is similar to =do=, but runs commands instead of normal Lisp
     expressions.  Currently, this command is only useful when used with the
     =if= command.

     #+begin_src emacs-lisp
       ;; Report whether an even number is found, or return the sum of
       ;; the list's elements.  To be clear, this is not an idiomatic example.

       ;; Returns sum:
       ;; => 9
       (loopy (list i '(1 3 5))
              (if (cl-evenp i)
                  (group
                   (do (message "Even found."))
                   (return i))
                (sum i)))

       ;; Returns the detected even number:
       ;; => 2
       (loopy (list i '(1 3 2 5))
              (if (cl-evenp i)
                  (command-do
                   (do (message "Even found."))
                   (return i))
                (sum i)))
     #+end_src

   #+findex: set-prev, prev-set, prev-expr, prev
   - =(set-prev|prev-set|prev-expr|prev VAR VAL &key init back)= :: Bind =VAR=
     to a value =VAL= from a previous cycle in the loop.  =VAR= is initialized
     to =INIT= or nil.  With =BACK=, use the value from that many cycles
     previous.

     As in =set=, when using destructuring, each variable is initialized to
     =INIT=, not a destructured part of =INIT=.

     #+begin_src emacs-lisp
       ;; => (nil 1 2 3 4)
       (loopy (list i '(1 2 3 4 5))
              (set-prev j i)
              (collect j))

       ;; (nil nil nil 1 2)
       (loopy (list i '(1 2 3 4 5))
              (set-prev j i :back 3)
              (collect j))

       ;; => ((7 7 1 3) (7 7 2 4))
       (loopy (list i '((1 2) (3 4) (5 6) (7 8)))
              (set-prev (a b) i :back 2 :init 7)
              (collect c1 a)
              (collect c2 b)
              (finally-return c1 c2))

       ;; NOTE: `prev-expr' keeps track of the previous value of `i',
       ;;       even when `j' isn't updated.
       ;;
       ;; => (first-val first-val 2 2 4 4 6 6 8 8)
       (loopy (numbers i 1 10)
              (when (cl-oddp i)
                (set-prev j i :init 'first-val))
              (collect j))
     #+end_src

** Iteration
   :PROPERTIES:
   :CUSTOM_ID: iteration-and-looping-commands
   :DESCRIPTION: Iterating through sequences, etc.
   :END:

   Iteration commands bind local variables and determine when the loop ends.  If
   no command sets an ending condition, then the loop runs forever.  Infinite
   loops can be exited by using early-exit commands ([[#exiting-the-loop-early]]) or
   boolean commands ([[#boolean-commands]]).

   Iteration commands must occur in the top level of the ~loopy~ form or in a
   =sub-loop= command.  Trying to do something like the below will signal an
   error.

   #+begin_src emacs-lisp
     ;; Signals an error:
     (loopy (list i '(1 2 3 4 5))
            (when (cl-evenp i)
              ;; Can't use `list' in a `when'.
              ;; Will signal an error.
              (list j '(6 7 8 9 10))
              (collect j)))
   #+end_src


   In ~loopy~, iteration commands are named after what they iterate through.
   For example, the =array= and =list= commands iterate through the elements of
   arrays and lists, respectively.  For the sake of familiarity, these commands
   also have aliases based on their equivalent =for=-clause from ~cl-loop~.  To
   translate =for VAR in LIST= from ~cl-loop~, one can use either
   =(list VAR LIST)= or =(in VAR LIST)=.


*** Generic Iteration
   :PROPERTIES:
   :CUSTOM_ID: generic-iteration
   :DESCRIPTION: Looping a certain number of times.
   :END:

    #+findex: cycle, repeat
    - =(cycle|repeat [VAR] EXPR)= :: Add a condition that the loop should stop
      after =EXPR= iterations.  If specified, =VAR= starts at 0, and is
      incremented by 1 at the end of the loop.  If =EXPR= is 0, then the loop
      isn't run.

      #+BEGIN_SRC emacs-lisp
        (loopy (cycle 3)
               (do (message "Messaged three times.")))

        (loopy (repeat i 3)
               (do (message "%d" i)))

        ;; An argument of 0 stops the loop from running:
        ;; => nil
        (loopy (cycle 0)
               (collect 'some-value))
      #+END_SRC


*** Numeric Iteration
:PROPERTIES:
:CUSTOM_ID: numeric-iteration
:DESCRIPTION: Iterating through numbers.
:END:

For iterating through numbers, there is the general =nums= command, and its
variants =nums-up= and =nums-down=.

#+findex: num, nums, number, numbers
- =(nums|num|number|numbers VAR [START [END] [STEP]] &key KEYS)= :: Iterate
  through numbers.  =KEYS= is one or several of =from=, =upfrom=, =downfrom=,
  =to=, =upto=, =downto=, =above=, =below=, and =by=.

  The command =nums= is used to iterate through numbers.  For example, =(nums i
  1 10)= is similar to =(list i (number-sequence 1 10))=, and =(nums i 3)= is
  similar to =(set i 3 (1+ i))=.

  To balance convenience and similarity to other commands, =nums= has a flexible
  argument list.  In its most basic form, it uses no keywords and takes a
  starting value and an ending value.  The ending value is inclusive.

  #+begin_src emacs-lisp
    ;; => (1 2 3 4 5)
    (loopy (nums i 1 5)
           (collect i))
  #+end_src

  If the ending value is not given, then the value is incremented by 1 without
  end.

  #+begin_src emacs-lisp
    ;; => (7 8 9 10 11 12 13 14 15 16)
    (loopy (cycle 10)
           (nums i 7)
           (collect i))
  #+end_src

  To specify the step size, one can use an optional third argument (like in
  Python's ~range~) or the keyword =:by= (like in ~cl-loop~). The value of the
  optional third argument can be positive or negative. /However/, in keeping
  with ~cl-loop~, the value for =:by= should always be positive; other keyword
  arguments then control whether the variable is incremented or decremented.

  #+begin_src emacs-lisp
    ;; => (1 3 5)
    (loopy (nums i 1 5 2)
           (collect i))

    ;; => (1 3 5)
    (loopy (nums i 1 5 :by 2)
           (collect i))

    ;; => (7 9 11 13 15 17 19 21 23 25)
    (loopy (cycle 10)
           (nums i 7 :by 2)
           (collect i))

    ;; => (1 2.5 4.0)
    (loopy (nums i 1 5 :by 1.5)
           (collect i))
  #+end_src

  By default, the variable's value starts at 0 and increases by 1.  To specify
  that the value should be increasing or decreasing when using the =:by=
  keyword, one can use the keywords =:downfrom=, =:downto=, =:upfrom=, and
  =:upto=.  The keywords =:from= and =:to= don't by themselves specify a
  direction.

  #+begin_src emacs-lisp
    ;; => (3 2 1)
    (loopy (cycle 3)
           (nums i :downfrom 3)
           (collect i))

    ;; => (0 -1 -2 -3)
    (loopy (nums i :downto -3)
           (collect i))

    ;; => (10 9 8 7 6 5 4 3 2)
    (loopy (nums i :downfrom 10 :to 2)
           (collect i))

    ;; => (10 8 6 4 2)
    (loopy (nums i :from 10 :downto 2 :by 2)
           (collect i))

    ;; Produced code is not as efficient as above:
    ;; => (10 8 6 4 2)
    (loopy (nums i 10 2 -2)
           (collect i))

    ;; => (1 2 3 4 5 6 7)
    (loopy (nums i :from 1 :upto 7)
           (collect i))
  #+end_src

  To specify an /exclusive/ ending value, use the keywords =:below= for
  increasing values and =:above= for decreasing values.

  #+begin_src emacs-lisp
    ;; => (1 2 3 4 5 6 7 8 9)
    (loopy (nums i :from 1 :below 10)
           (collect i))

    ;; Same as
    (loopy (set i 1 (1+ i))
           (while (< i 10))
           (collect i))

    ;; => (10 9 8 7 6 5 4 3 2)
    (loopy (nums i :from 10 :above 1)
           (collect i))

    ;; => (0 -1 -2)
    (loopy (nums i :above -3)
           (collect i))
  #+end_src

  #+ATTR_TEXINFO: :tag Note
  #+begin_quote
  Because the ~loopy~ macro can't test the value of the step size ahead of time,
  being more explicit by using the keyword parameters can produce faster code.
  #+end_quote


If you prefer using positional arguments to keyword arguments, you can use the
commands =nums-up= and =nums-down= to specify directions.  These commands are
simple wrappers of the above =nums= command.

#+findix: nums-down, numbers-down
- =(nums-down|numsdown|numbers-down VAR START [END] &key by)= :: Equivalent to
  =(nums VAR START [:downto END] &key by)=.  This command exists only for
  convenience.

  #+begin_src emacs-lisp
    ;; => (10 8 6 4 2)
    (loopy (nums-down i 10 1 :by 2)
           (collect i))

    ;; => (10 8 6 4 2)
    (loopy (nums-down i 10 1 2)
           (collect i))
  #+end_src

#+findix: nums-up, numbers-up
- =(nums-up|numsup|numbers-up VAR START [END] &key by)= :: Equivalent to =(nums
  VAR START [END] &key by)=.  This command exists only for convenience.

  #+begin_src emacs-lisp
    ;; => (1 3 5 7 9)
    (loopy (nums-up i 1 10 :by 2)
           (collect i))

    ;; => (1 3 5 7 9)
    (loopy (nums-up i 1 10 2)
           (collect i))
  #+end_src


*** Sequence Iteration
    :PROPERTIES:
    :CUSTOM_ID: sequence-iteration
    :DESCRIPTION: Iterating through sequences.
    :END:

    These commands provide various ways to iterate through sequences
    ([[info:elisp#Sequences Arrays Vectors]]).

    #+cindex: sequence element distribution
    Instead of iterating through just one sequence, the =array=, =list=, and
    =seq= commands can be given multiple sequences of various sizes.  In such
    cases, the elements of the sequences are {{{dfn(distributed)}}}, like in the
    distributive property from mathematics.  A new sequence of distributed
    elements is created before the loop runs, and that sequence is used for
    iteration instead of the source sequences.  As seen in the below example,
    the resulting behavior is similar to that of nested loops.

    #+begin_src emacs-lisp
      ;; => ((1 3 6) (1 4 6) (1 5 6) (2 3 6) (2 4 6) (2 5 6))
      (loopy (list i '(1 2) '(3 4 5) '(6))
             (collect i))

      ;; Gives the same result as this
      (let ((result nil))
        (dolist (i '(1 2))
          (dolist (j '(3 4 5))
            (dolist (k '(6))
              (push (list i j k) result))))
        (nreverse result))

      ;; and this
      (cl-loop for i in '(1 2)
               append (cl-loop for j in '(3 4 5)
                               append (cl-loop for k in '(6)
                                               collect (list i j k))))
    #+end_src


    The =array= and =sequence= commands can use the same keywords as the =nums=
    command ([[#numeric-iteration]]) for working with the index and choosing a range
    of the sequence elements through which to iterate.  In addition to those
    keywords, they also have an =index= keyword, which names the variable used
    to store the accessed index during the loop.

    #+begin_src emacs-lisp
      ;; => ((1 . 9) (3 . 6) (5 . 5) (7 . 3) (9 . 1))
      (loopy (array i [10 9 8 6 7 5 4 3 2 1] :from 1 :by 2 :index ind)
             (collect (cons ind i)))
    #+end_src

    Keep in mind that if used with sequence distribution, these keywords affect
    iterating through the sequence of distributed elements.  That is, they do
    not affect how said sequence is produced.  In the example below, see that
    ~cddr~ is applied to the sequence of distributed elements.  It is /not/
    applied to the source sequences.

    #+begin_src emacs-lisp
      ;; This code creates the sequence of distributed elements
      ;; ((1 4) (1 5) (1 6) (2 4) (2 5) (2 6) (3 4) (3 5) (3 6))
      ;; and then moves through this sequence using `cddr'.
      ;;
      ;; => ((1 4) (1 6) (2 5) (3 4) (3 6))
      (loopy (list i '(1 2 3) '(4 5 6) :by #'cddr)
             (collect i))

      ;; Not the same as:
      ;; => ((1 4) (1 6) (3 4) (3 6))
      (loopy (list i '(1 3) '(4 6))
             (collect i))
    #+end_src


    #+findex: array, string, across
    - =(array|string|across VAR EXPR [EXPRS] &key KEYS)= :: Loop through the
      elements of the array =EXPR=.  In Emacs Lisp, strings are arrays whose
      elements are characters.

      =KEYS= is one or several of =from=, =upfrom=, =downfrom=, =to=, =upto=,
      =downto=, =above=, =below=, =by=, and =index=.  =index= names the variable
      used to store the index being accessed.  For others, see the =nums=
      command.

      If multiple arrays are given, then the elements of these arrays are
      distributed into an array of lists.  In that case, the above keywords
      apply to this new, resulting array of lists.

      #+BEGIN_SRC emacs-lisp
        (loopy (array i [1 2 3])
               (do (message "%d" i)))

        ;; => (1 3)
        (loopy (array i [1 2 3 4] :by 2)
               (collect i))

        ;; Collects the integer values representing each character.
        ;; => (97 98 99)
        (loopy (string c "abc")
               (collect c))

        ;; This is the same as using [(1 3) (1 4) (2 3) (2 4)].
        ;; => ((1 3) (1 4) (2 3) (2 4))
        (loopy (array i [1 2] [3 4])
               (collect i))

        ;; => ((1 3) (2 3))
        (loopy (array i [1 2] [3 4] :by 2)
               (collect i))
      #+END_SRC

    #+findex: cons, conses, on
    - =(cons|conses|on VAR EXPR &key by)= :: Loop through the cons cells of
      =EXPR=.  Optionally, find the cons cells via function =by= instead of
      =cdr=.

      #+BEGIN_SRC emacs-lisp
        (loopy (cons i '(1 2 3))
               (collect coll i)
               (finally-return coll)) ; => ((1 2 3) (2 3) (3))
      #+END_SRC

    #+findex: list, in, each
    - =(list|in|each VAR EXPR [EXPRS] &key by)= :: Loop through each element of
      the list =EXPR=.  Optionally, update the list by =by= instead of =cdr=.

      If multiple lists are given, distribute the elements of the lists into one
      new list.  In such cases, =by= applies to the new list, not the arguments
      of the command.

      #+BEGIN_SRC emacs-lisp
        (loopy (list i (number-sequence 1 10 3)) ; Inclusive, so '(1 4 7 10).
               (do (message "%d" i)))

        ;; => ((1 4) (1 5) (1 6) (2 4) (2 5) (2 6) (3 4) (3 5) (3 6))
        (loopy (list i '(1 2 3) '(4 5 6))
               (collect i))

        ;; => ((1 4) (1 6) (2 5) (3 4) (3 6))
        (loopy (list i '(1 2 3) '(4 5 6) :by #'cddr)
               (collect i))
      #+END_SRC

    #+findex: map, map-pairs
    - =(map|map-pairs VAR EXPR &key unique)= :: Iterate through the dotted key-value pairs
      of =EXPR=, using the function ~map-pairs~ from the =map.el= library.  This
      library generalizes working with association lists ("alists"), property
      lists ("plists"), hash-tables, and vectors.

      In each dotted pair assigned to =VAR=, the ~car~ is the key and the ~cdr~
      is the value.

      By default, only the unique keys are used.  To disable this deduplication,
      pass ~nil~ to the =unique= keyword argument.

      You should not rely on the order in which the key-value pairs are found.

      These pairs are created before the loop begins.  In other words, the map
      =EXPR= is not processed progressively, but all at once.  Therefore, this
      command can have a noticeable start-up cost when working with very large
      maps.

      #+begin_src emacs-lisp
        ;; => ((a . 1) (b . 2))
        (loopy (map pair '((a . 1) (b . 2)))
               (collect pair))

        ;; => ((a b) (1 2))
        (loopy (map (key . value) '((a . 1) (b . 2)))
               (collect keys key)
               (collect values value)
               (finally-return keys values))

        ;; => ((:a :b) (1 2))
        (loopy (map (key . value) '(:a  1 :b 2))
               (collect keys key)
               (collect values value)
               (finally-return keys values))

        ;; NOTE: For vectors, the keys are indices.
        ;; => ((0 1) (1 2))
        (loopy (map (key . value) [1 2])
               (collect keys key)
               (collect values value)
               (finally-return keys values))

        ;; => ((a b) (1 2))
        (let ((my-table (make-hash-table)))
          (puthash 'a 1 my-table)
          (puthash 'b 2 my-table)

          (loopy (map (key . value) my-table)
                 (collect keys key)
                 (collect values value)
                 (finally-return keys values)))
      #+end_src

      Depending on how a map is created, a map might repeat a key multiple
      times.  Currently, the function ~map-pairs~ returns such keys.  By
      default, the command =map-pairs= ignores such duplicate keys.  This is for
      two reasons:
      1. This is more consistent with the command =map-ref=, for which such
         duplicates are more likely to cause errors.
      2. For maps that can have duplicate keys (alists, plists, etc.), there are
         already other iteration commands (=list=, =cons=, etc.) that explicitly
         include the duplicates.

      Again, this can be disabled by setting =unique= to nil.

      #+begin_src emacs-lisp
        ;; A comparison of setting the `unique' key to nil:
        ;;
        ;; => ((a 1) (a 2) (b 3))
        (loopy (map (key . val) '((a . 1) (a . 2) (b . 3)) :unique nil)
               (collect (list key val)))

        ;; In this case, `list' has the same result:
        ;; => ((a 1) (a 2) (b 3))
        (loopy (list (key . val) '((a . 1) (a . 2) (b . 3)))
               (collect (list key val)))

        ;; => ((:a 1) (:a 2) (:b 3))
        (loopy (map (key . val) '(:a 1 :a 2 :b 3) :unique nil)
               (collect (list key val)))

        ;; In this case, `cons' has the same result:
        ;; => ((:a 1) (:a 2) (:b 3))
        (loopy (cons (key val) '(:a 1 :a 2 :b 3) :by #'cddr)
               (collect (list key val)))
      #+end_src

    #+findex: seq, sequence, elements
    - =(seq|sequence|elements VAR EXPR [EXPRS] &key KEYS)= :: Loop through the
      sequence =EXPR=, binding =VAR= to the elements of the sequence.  This is a
      more generic form of the commands =list= and =array=, though it is
      somewhat less efficient.

      =KEYS= is one or several of =from=, =upfrom=, =downfrom=, =to=, =upto=,
      =downto=, =above=, =below=, =by=, and =index=.  =index= names the variable
      used to store the index being accessed.  For others, see the =nums=
      command.

      If multiple sequences are given, then these keyword arguments apply to the
      resulting sequence of distributed elements.

      #+BEGIN_SRC emacs-lisp
        ;; => (1 2 3)
        (loopy (seq i [1 2 3])
               (collect coll i)
               (finally-return coll))

        ;; => (0 2 4)
        (loopy (seq i [0 1 2 3 4 5] :by 2)
               (collect i))

        ;; => (1 3 5)
        (loopy (seq i [0 1 2 3 4 5 6]
                    :by 2 :from 1 :to 5)
               (collect i))

        ;; => (5 3 1)
        (loopy (seq i '(0 1 2 3 4 5 6)
                    :downfrom 5 :by 2 :to 1)
               (collect i))

        ;; => ((1 3) (1 4) (2 3) (2 4))
        (loopy (seq i [1 2] '(3 4))
               (collect i))

        ;; => ((1 3) (2 3))
        (loopy (seq i [1 2] '(3 4) :by 2)
               (collect i))
      #+END_SRC

*** Sequence Index Iteration
    :PROPERTIES:
    :CUSTOM_ID: sequence-index-iteration
    :DESCRIPTION: Iterating through indices without accessing values.
    :END:

    This command is for iterating through a sequence's indices without accessing
    the actual values of that sequence.  This is helpful if you know ahead of
    time that you are only interested in a small subset of the sequence's
    elements.

    As with the =array= and =seq= commands, the =seq-index= command can use the
    same keywords as the =nums= command ([[#numeric-iteration]]) for working with
    the index and choosing a range of the sequence elements through which to
    iterate.

    #+findex: seq-index, seqi, array-index, arrayi, list-index, listi, string-index, stringi
    - =(seq-index VAR EXPR &key KEYS)= :: Iterate through the indices of =EXPR=.

      There is only one implementation of this command; there are no
      type-specific versions.  For clarity and convenience, this command has the
      aliases =array-index=, =list-index=, and =string-index=.  In keeping with
      aliases like =seqf= for the =seq-ref= command, this command also has the
      aliases =seqi=, =arrayi=, =listi=, and =stringi=.

      =KEYS= is one or several of =from=, =upfrom=, =downfrom=, =to=, =upto=,
      =downto=, =above=, =below=, and =by=.  For their meaning, see the =nums=
      command.  This command is very similar to =nums=, except that it can
      automatically end the loop when the final element is reached.  With
      =nums=, one would first need to explicitly calculate the length of the
      sequence.

      #+begin_src emacs-lisp
        ;; => (97 98 99 100 101 102)
        (loopy (with (my-string "abcdef"))
               (string-index idx my-string)
               (collect (aref my-string idx)))

        ;; Works the same as
        (loopy (with (my-string "abcdef"))
               (nums idx :from 0 :below (length my-string))
               (collect (aref my-string idx)))
      #+end_src

      This command does not support destructuring.

      #+begin_src emacs-lisp
        ;; => (0 1 2)
        (loopy (seq-index i [1 2 3])
               (collect i))

        ;; => (0 1 2)
        (loopy (array-index i "abc")
               (collect i))

        ;; => (0 1 2)
        (loopy (list-index i '(1 2 3))
               (collect i))

        ;; => (8 6 4 2)
        (loopy (with (my-seq [0 1 2 3 4 5 6 7 8 9 10]))
               (seq-index idx my-seq :from 8 :downto 1 :by 2)
               (collect (elt my-seq idx)))
      #+end_src

*** Sequence Reference Iteration
    :PROPERTIES:
    :CUSTOM_ID: sequence-reference-iteration
    :DESCRIPTION: Iterating through places/fields in sequences.
    :END:

    These commands all iterate through ~setf~-able places as generalized
    variables ([[info:elisp#Generalized Variables]]).  These generalized variables
    are commonly called "references", "fields", or "places".  The below example
    demonstrates using ~(nth 1 my-list)~ and ~(aref my-array 1)~ as ~setf~-able
    places.

    #+begin_src emacs-lisp
      ;; => (1 99 3 4 5)
      (let ((my-list '(1 2 3 4 5)))
        (setf (nth 1 my-list) 99)
        my-list)

      ;; => [(1 2 3) (4 . 99)]
      (let ((my-array [(1 2 3) (4 5 6)]))
        (setf (cdr (aref my-array 1)) 99)
        my-array)
    #+end_src

    Like other commands, "field" or "reference" commands can also use
    destructuring, in which case the fields/places of the sequence are
    destructured into "sub-fields", like the ~cdr~ of the second array element
    in the example above.

    #+attr_texinfo: :tag Caution
    #+begin_quote
    Be aware that using ~setf~ on an array sub-sequence named by =&rest=
    will only overwrite values, not truncate or grow the array.
    #+end_quote

    #+attr_texinfo: :tag Warning
    #+begin_quote
    Unfortunately, not all kinds of recursive destructuring work on references.
    This is a limitation of how generic setters are implemented, and is not
    limited to ~loopy~.

    Currently, the variable after =&rest= in arrays cannot be recursive.
    #+end_quote

    As with the =array= and =seq= commands, the =array-ref= and =seq-ref=
    commands can use the same keywords as the =nums= command
    ([[#numeric-iteration]]) for working with the index and choosing a range of the
    sequence elements through which to iterate.  In addition to those keywords,
    they also have an =index= keyword, which names the variable used to store
    the accessed index during the loop.

    #+findex: array-ref, arrayf, string-ref, stringf, across-ref
    - =(array-ref|arrayf|string-ref|stringf|across-ref VAR EXPR &key KEYS)= :: Loop
      through the elements of the array =EXPR=, binding =VAR= as a ~setf~-able
      place.

      =KEYS= is one or several of =from=, =upfrom=, =downfrom=, =to=, =upto=,
      =downto=, =above=, =below=, =by=, and =index=.  =index= names the variable
      used to store the index being accessed.  For others, see the =nums=
      command.

      #+BEGIN_SRC emacs-lisp
        ;; => "aaa"
        (loopy (with (my-str "cat"))
               (array-ref i my-str)
               (do (setf i ?a))
               (finally-return my-str))

        ;; => "0a2a4a6a89"
        (loopy (with (my-str "0123456789"))
               (array-ref i my-str :from 1 :by 2 :to 7)
               (do (setf i ?a))
               (finally-return my-str))

        ;; Works the same as
        (loopy (with (my-str "0123456789"))
               (nums idx 1 7 :by 2)
               (do (setf (aref my-str idx) ?a))
               (finally-return my-str))
      #+END_SRC

    #+findex: list-ref, listf, in-ref
    - =(list-ref|listf|in-ref VAR EXPR &key by)= :: Loop through the elements of
      the list =EXPR=, binding =VAR= as a ~setf~-able place.  Optionally, update
      the list via function =by= instead of ~cdr~.

      #+BEGIN_SRC emacs-lisp
        ;; => (7 7 7)
        (loopy (with (my-list '(1 2 3)))
               (list-ref i my-list)
               (do (setf i 7))
               (finally-return my-list))

        ;; Works similar to
        (loopy (with (my-list '(1 2 3)))
               (nums idx :below (length my-list))
               (do (setf (nth idx my-list) 7))
               (finally-return my-list))

        ;; => (7 2 7)
        (loopy (with (my-list '(1 2 3)))
               (list-ref i my-list :by #'cddr)
               (do (setf i 7))
               (finally-return my-list))

        ;; => ([1 7] [2 7])
        (loopy (with (my-list '([1 2] [2 3])))
               (list-ref [_ i] my-list)
               (do (setf i 7))
               (finally-return my-list))
      #+END_SRC

    #+findex: map-ref, mapf
    - =(map-ref|mapf VAR EXPR &key key unique)= :: Loop through the values of
      map =EXPR=, binding =VAR= as a ~setf~-able place.  Like the command =map=,
      this command uses the =map.el= library.

      =key= is a variable in which to store the current key for the ~setf~-able
      place referred to by =VAR=.  This is similar to the =index= keyword
      parameter of other commands.

      Like in the command =map=, the keys of the map are generated before the
      loop is run, which can be expensive for large maps.

      Similar to =map=, any duplicate keys are ignored by default.  This can be
      disabled by setting the =unique= keyword argument to nil, though note that
      using such duplicate keys will still refer to the value of the first
      occurence.  There is no way to use a duplicate key to refer to the
      duplicate's value.

      #+begin_src emacs-lisp
        ;; Duplicate keys are ignored by default.
        ;;
        ;; => (:a 8 :a 'ignored :b 10)
        (loopy (with (map (list :a 1 :a 'ignored :b 3)))
               (map-ref i map)
               (do (cl-incf i 7))
               (finally-return map))

        ;; If duplicates are not ignored:
        ;;
        ;; => (:a 15 :a ignored :b 10)
        (loopy (with (map (list :a 1 :a 'ignored :b 3)))
               (map-ref i map :unique nil)
               (do (cl-incf i 7))
               (finally-return map))

        ;; Getting the key using `key':
        ;;
        ;; => (((cat . 7)       ; The map itself
        ;;      (dog . 7)
        ;;      (zebra . 7))
        ;;     (cat dog zebra)) ; The keys
        (loopy (with (map (list (cons 'cat 1)
                                (cons 'dog 2)
                                (cons 'zebra 3))))
               (map-ref i map :key my-key)
               (do (setf i 7))
               (collect my-key)
               (finally-return map loopy-result))
      #+end_src

    #+findex: seq-ref, seqf, sequence-ref, sequencef, elements-ref
    - =(seq-ref|seqf|sequence-ref|sequencef|elements-ref VAR EXPR &key KEYS)= :: Loop
      through the elements of the sequence =EXPR=, binding =VAR= as a
      ~setf~-able place.

      =KEYS= is one or several of =from=, =upfrom=, =downfrom=, =to=, =upto=,
      =downto=, =above=, =below=, =by=, and =index=.  =index= names the variable
      used to store the index being accessed.  For others, see the =nums=
      command.

      #+BEGIN_SRC emacs-lisp
        ;; => (7 7 7 7)
        (loopy (with (my-seq '(1 2 3 4)))
               (seq-ref i my-seq)
               (do (setf i 7))
               (finally-return my-seq))

        ;; => (0 cat 2 cat 4 cat 6 cat 8 cat)
        (loopy (with (my-list '(0 1 2 3 4 5 6 7 8 9)))
               (seq-ref i my-list :from 1 :by 2 )
               (do (setf i 'cat))
               (finally-return my-list))

        ;; => "0123456a8a"
        (loopy (with (my-str "0123456789"))
               (seq-ref i my-str :downto 6 :by 2 )
               (do (setf i ?a))
               (finally-return my-str))
      #+END_SRC

** Accumulation
   :PROPERTIES:
   :CUSTOM_ID: accumulation-commands
   :DESCRIPTION: Accumulating values into new sequences, aggregating values, etc.
   :END:

   Accumulation commands are used to accumulate or aggregate values into a
   variable, such as creating a list of values or summing the elements in
   a sequence.

   If needed, you can refer to the same accumulation variable in multiple
   accumulation commands.

   #+begin_src emacs-lisp
     ;; => (1 6 2 7 3 8)
     (loopy (list i '(1 2 3))
            (collect coll i)
            (collect coll (+ i 5))
            (finally-return coll))
   #+end_src

   #+attr_texinfo: :tag Note
   #+begin_quote
   Keep in mind that it is an error to modify accumulation variables outside of
   accumulation commands.  This restriction allows accumulations to be much
   faster.
   #+end_quote

   Like with other loop commands, variables created by accumulation commands
   (such as =coll= in the above example) are initialized to ~nil~ unless
   stated otherwise.

   #+cindex: accumulation destructuring
   Similar to iteration commands, accumulation commands can also use
   destructuring.  In accumulation commands, the values resulting from
   destructuring are accumulated, instead of the destructured value.

   #+begin_src emacs-lisp
     ;; => ((1 4) (2 5) (3 6))
     (loopy (list elem '((1 2 3) (4 5 6)))
            (collect (coll1 coll2 coll3) elem)
            (finally-return coll1 coll2 coll3))

     ;; => (5 7 9)
     (loopy (list elem '((1 2 3) (4 5 6)))
            (sum (sum1 sum2 sum3) elem)
            (finally-return sum1 sum2 sum3))

     ;; Returns the same values as above.
     (loopy (list elem '((1 2 3) (4 5 6)))
            (set sum1 (cl-first elem)  (+ sum1 (cl-first elem)))
            (set sum2 (cl-second elem) (+ sum2 (cl-second elem)))
            (set sum3 (cl-third elem)  (+ sum3 (cl-third elem)))
            (finally-return sum1 sum2 sum3))
   #+end_src


   #+cindex: implied/implicit accumulation results
   #+vindex: loopy-result
   Like in ~cl-loop~, you do not need to supply a variable name to accumulation
   commands.  If no accumulation variable is given, accumulation commands will
   use the variable ~loopy-result~.  This variable is accessible in the
   =after-do=, =finally-do=, and =finally-return= special macro arguments.  You
   should not attempt to modify this variable.  If you wish to override what
   would be returned by the macro, simply use the =finally-return= macro
   argument as you normally would.

   #+begin_src emacs-lisp
     ;; => (1 2 3)
     (loopy (list i '(1 2 3))
            (collect i)
            (after-do (cl-return loopy-result)))

     ;; => (1 2 3)
     (loopy (list i '(1 2 3))
            (collect i)
            (finally-return loopy-result))

     ;; => (0 1 2 3)
     (loopy (list i '(1 2 3))
            (collect i)
            (else-do (push 0 loopy-result)
                     (cl-return loopy-result)))

     ;; => (0 1 2 3)
     (loopy (list i '(1 2 3))
            (collect i)
            (finally-do (push 0 loopy-result))
            (finally-return loopy-result))
   #+end_src

   #+cindex: implied/implicit return values
   Using an accumulation command without naming a variable implies a return
   value for the macro, which you can override using the =return= and
   =return-from= loop commands or the =finally-return= macro argument.

   #+begin_src emacs-lisp
     ;; => (1 2 3)
     (loopy (list i '(1 2 3))
            (collect i))

     ;; => overridden
     (loopy (list i '(1 2 3))
            (collect i)
            (finally-return 'overridden))
   #+end_src


   Be aware that explicitly named accumulation variables do not affect this
   implied return value.  Such values must be returned explicitly, or they will
   be ignored when the macro returns a values.  This limitation is needed for
   more consistently handling the complexity that comes from allowing unknown
   kinds of destructuring via the alternative destructuring systems.  This may
   change in the future.

   #+begin_src emacs-lisp
     ;; => (1 2 3)
     (loopy (list i '(1 2 3))
            (collect i)
            (collect my-other-collection (* 2 i))
            (collect (a b) (list i (* 2 i))))
   #+end_src

   Therefore, when mixing implicit and explicit accumulation variables, you must
   use the =finally-return= special macro argument to return all of the
   accumulation results.

   #+begin_src emacs-lisp
     ;; => ((1 2 3) (2 4 6) (1 2 3) (2 4 6))
     (loopy (list i '(1 2 3))
            (collect i)
            (collect my-other-collection (* 2 i))
            (collect (a b) (list i (* 2 i)))
            (finally-return loopy-result
                            my-other-collection
                            a b))
   #+end_src

   When using implied variables, multiple accumulation commands will use the
   same variable (that is, they will all accumulate into ~loopy-result~).  You
   should ensure that such accumulations are actually compatible, otherwise
   ~loopy~ will raise an error.  For example, you should not try to accumulate
   =collect= results and =sum= results into the same variable, as you cannot use
   a list as a number.  On the other hand, =sum= and =multiply= are compatible,
   since they both act on numbers.

   #+begin_src emacs-lisp
     ;; => (3 2 1 11 12 13)
     (loopy (nums i 1 3)
            (collect i :at start)
            (collect (+ i 10) :at end))

     ;; Algebraic style: ((((0 + 1) * 1) + 2) * 2 + 3) * 3 = 27
     ;; RPN style: 0 1 + 1 * 2 + 2 * 3 + 3 *
     ;; => 27
     (loopy (nums i 1 3)
            (sum i)
            (multiply i))

     ;; As an aside, note the difference between summing first and multiplying
     ;; first.  Besides the order of operations, variables that are summed first
     ;; are initialized to 0, while variables that are multiplied first
     ;; are initialized to 1.
     ;;
     ;; => 21
     (loopy (nums i 1 3)
            (multiply i)
            (sum i))
   #+end_src

   #+attr_texinfo: :tag Warning
   #+begin_quote
   You should not try to access implied accumulation results (e.g.,
   ~loopy-result~) while the loop is running.  Implied results are only required
   to be correct after the loop ends (before code in =else-do= is run), allowing
   for more efficient code.

   Furthermore, because using a =return= or =return-from= command overrides
   implied return values, using these commands can prevent implied accumulation
   results from being finalized.  Using the =leave= command, which exits the
   loop without returning a value, does not affect the correctness of implied
   results.
   #+end_quote

   By default, one must specify accumulation variables in order to accumulate
   into separate values.  If, for some reason, you wish to always used implied
   variables during a loop, you can enable the =split= flag ([[#flags]]).
   This flag makes ~loopy~ generate a unique implied variable for each
   accumulation command.

   When the =split= flag is enabled and after the loop completes, each of these
   split accumulation variables will be part of the list ~loopy-result~,
   appearing in the same order as their respective commands in the macro's
   arguments.  In the example below, note that the result of ~(collect i)~ is
   the first element of ~loopy-result~, even though the collection happens
   /after/ the first summation when the loop runs.

   #+begin_src emacs-lisp
     ;; => ((2 4) 15)
     (loopy (flag split)
            (nums i 1 5)
            (when (cl-evenp i)
              (collect i))
            (sum i)
            ;; NOTE: This `finally-return' isn't needed, as `loopy-result'
            ;; is already the implied return value.
            (finally-return loopy-result))
   #+end_src

***  Accumulation Commands

   #+cindex: accumulation keyword arguments
   Some accumulation commands have optional keyword parameters, which are listed
   in the command's definition.  To avoid repetition, the common parameters are
   all described below.

   #+cindex: accumulation keyword at
   - =at= :: Where to place a value.  One of =end=, =start=, or =beginning=
     (equivalent to =start=).  If ungiven, defaults to =end=.  These positions
     need not be quoted.

   #+cindex: accumulation keyword into
   - =into= :: An alternative way to specify the variable into which to
     accumulate values.  One would normally just give =VAR= as the first
     argument of the loop command, but if you wish, you can use this keyword
     argument for a more ~cl-loop~-like syntax.

     As all accumulation commands support this keyword, it is not listed in
     any command definition.

   #+cindex: accumulation keyword test
   - =test= :: A function of two arguments, usually used to test for equality.
     Most tests default to ~equal~, like in other Emacs Lisp libraries.  This is
     different from ~cl-lib~, which mimics Common Lisp and prefers using ~eql~.

   #+cindex: accumulation keyword key
   - =key= :: A function of one argument, used to transform the inputs of
     =test=.

   #+cindex: accumulation keyword init
   - =init= :: The initial value of =VAR=.  For explicitly named variables, one
     can use this argument or the =with= special macro argument.  When using the
     =split= flag, this argument is the only way to specify a non-default
     initial value.

   #+cindex: accumulation keyword result-type
   - =result-type= :: A sequence type into which =VAR= is converted /after the
     loop is over/.  These types need not be quoted.  For example, ='vector= and
     =vector= are both valid ways to specify the vector data type.

     This argument can be more convenient than writing out a call to ~cl-coerce~
     or ~seq-into~.

   The arguments to the =test= and =key= parameters can be quoted functions or
   variables, just like when using ~cl-union~, ~cl-adjoin~, and so on.  ~loopy~
   knows how to expand efficiently for either case.

   #+attr_texinfo: :tag Note
   #+begin_quote
   You will notice that each accumulation command has an alias of the command
   name in the present participle form (the "-ing" form).

   For example, instead of "min" or "minimize", you can use "minning" or
   "minimizing".  Instead of "sum" and "append", you can use "summing" and
   "appending".  This is similar to the behavior of ~cl-loop~, and helps to
   avoid name collisions when using the ~loopy-iter~ macro with the =lax-naming=
   flag enabled ([[#loopy-iter][The ~loopy-iter~ Macro]]).
   #+end_quote


   The available accumulation commands are:

   #+findex: accumulate
   - =(accumulate|accumulating VAR EXPR FUNC &key init)= :: Accumulate the
     result of applying function =FUNC= to =EXPR= and =VAR=.  =EXPR= and =VAR=
     are used as the first and second arguments to =FUNC=, respectively.

     This is a generic accumulation command in case the others don't meet your
     needs.  It is similar in effect to using the command =expr=.

     #+begin_src emacs-lisp
       ;; Call `(cons i my-accum)'
       ;;
       ;; => (2 1)
       (loopy (list i '(1 2))
              (accumulate my-accum i #'cons :init nil)
              (finally-return my-accum))

       ;; Works mostly the same as the above:
       (loopy (list i '(1 2))
              (set my-accum (cons i my-accum))
              (finally-return my-accum))

       ;; => ((3 1) (4 2))
       (loopy (list i '((1 2) (3 4)))
              (accumulate (accum1 accum2) i #'cons :init nil)
              (finally-return accum1 accum2))
     #+end_src

     This command also has the alias =callf2=.  It is similar to using the
     function ~cl-callf2~, except that the function argument is given last and
     must be quoted.  This alias is intended to help users remember argument
     order.

     #+begin_src emacs-lisp
       (loopy (list i '(1 2))
              (callf2 my-accum i #'cons :init nil)
              (finally-return my-accum))

       ;; Is the same as the above:
       (loopy (with (my-accum))
              (list i '(1 2))
              (do (cl-callf2 cons i my-accum))
              (finally-return my-accum))
     #+end_src

   #+findex: adjoin
   - =(adjoin|adjoining VAR EXPR &key at test key init result-type)= :: Repeatedly
     add =EXPR= to =VAR= if it is not already present in the list.

     #+begin_src emacs-lisp
       ;; Without a test, defaults to `eql' as in `cl-adjoin'.
       ;; => ((1 . 1) (1 . 2) (1 . 2) (2 . 3))
       (loopy (list i '((1 . 1) (1 . 2) (1 . 2) (2 . 3)))
              (adjoin i))

       ;; Using `equal' for the test.
       ;; => ((1 . 1) (1 . 2) (2 . 3))
       (loopy (list i '((1 . 1) (1 . 2) (1 . 2) (2 . 3)))
              (adjoin i :test #'equal))

       ;; Using `=' for the test and `car' for the key.  This
       ;; treats '(1 . 2) as equivalent to '(1 . 1), so it
       ;; won't be added.
       ;;
       ;; => ((1 . 1) (2 . 3))
       (loopy (list i '((1 . 1) (1 . 2) (1 . 2) (2 . 3)))
              (adjoin i :test #'= :key #'car))

       ;; Coerced to a vector /after/ the loop ends.
       ;; => [1 2 3 4]
       (loopy (list i '(1 2 3 3 4))
              (adjoin my-var i :result-type 'vector)
              (when (vectorp my-var)
                (return 'is-vector))
              (finally-return my-var))

       ;; => [4 3 2 1]
       (loopy (list i '(1 2 3 3 4))
              (adjoin my-var i :result-type 'vector :at 'start)
              (finally-return my-var))
     #+end_src

   #+findex: append
   - =(append|appending VAR EXPR &key at)= :: Repeatedly concatenate =EXPR= to
     =VAR=, as if by the function ~append~.

     #+BEGIN_SRC emacs-lisp
       ;; => '(1 2 3 4 5 6)
       (loopy (list i '((1 2 3) (4 5 6)))
              (append coll i)
              (finally-return coll))

       ;; => (4 5 6 1 2 3)
       (loopy (list i '((1 2 3) (4 5 6)))
              (append i :at start))
     #+END_SRC

   #+findex: collect
   - =(collect|collecting VAR EXPR &key result-type at)= :: Collect the value of
     =EXPR= into the list =VAR=.  By default, elements are added to the end of
     the list.

     #+BEGIN_SRC emacs-lisp
       ;; => '(1 2 3)
       (loopy (list i '(1 2 3))
              (collect i))

       ;; => '((1 2 3) ((1) (1 2) (1 2 3)))
       (loopy (list i '(1 2 3))
              ;; Collect `i' into `coll1'.
              (collect coll1 i)
              ;; Collect `coll1' into a generated variable.
              (collect coll1)
              (finally-return coll1 loopy-result))

       ;; => [1 2 3]
       (loopy (list j '(1 2 3))
              (collect j :result-type 'vector))

       ;; => (3 2 1)
       (loopy (list j '(1 2 3))
              (collect j :at start))

       ;; => (1 2 3)
       (loopy (list j '(1 2 3))
              (collect j :at 'end))
     #+END_SRC

   #+findex: concat
   - =(concat|concating VAR EXPR &key at)= :: Repeatedly ~concat~ the value of
     =EXPR= onto =VAR=, as a string.  For concatenating values onto a vector, see
     the command =vconcat=.

     =VAR= is a string throughout the loop.  This differs from the behavior of
     commands with the keyword argument =result-type=, which coerces the
     resulting sequence of accumulated values into a new type /after/ the loop
     completes.

     #+BEGIN_SRC emacs-lisp
       ;; => "abc"
       (loopy (list i '("a" "b" "c"))
              (concat str i)
              (finally-return str))

       ;; => ("da" "eb" "fc")
       (loopy (list j '(("a" "b" "c") ("d" "e" "f")))
              (concat (str1 str2 str3) j :at 'start)
              (finally-return str1 str2 str3))
     #+END_SRC

   #+findex: count
   - =(count|counting VAR EXPR)= :: Count the number of times that =EXPR=
     evaluates to a non-nil value.  =VAR= starts at 0 and is incremented by 1
     each time.

     #+BEGIN_SRC emacs-lisp
       ;; => 3
       (loopy (list i '(1 nil 3 nil 5))
              (count non-nil-count i)
              (finally-return non-nil-count))
     #+END_SRC

   #+findex: find, finding
   - =(find|finding VAR EXPR TEST &key ON-FAILURE)= :: If =TEST= is
     non-nil, the loop stops and =EXPR= is used as a returned value.  If =TEST=
     is never non-nil, then =ON-FAILURE= is used as a returned value, if
     provided.

     =VAR= takes the value of =EXPR= if =TEST= is non-nil or =ON-FAILURE= if the
     loop completes successfully.  It is bound to ~nil~ during  the loop.  As
     with other accumulation commands, if =VAR= is provided, then =EXPR= is not
     used as a return value.  Instead, it is assigned to =VAR=, which must be
     returned explicitly.

     #+BEGIN_SRC emacs-lisp
       ;; => 3
       (loopy (list i '(1 2 3))
              (finding i (> i 2)))

       ;; => nil
       (loopy (list i '(1 2 3))
              (finding i (> i 4)))

       ;; => "not found"
       (loopy (list i '(1 2 3))
              (finding i (> i 4) :on-failure "not found"))

       ;; => 2
       ;; Does not display message.
       (loopy (list i '(1 2 3))
              (finding i (= i 2) :into found)
              (after-do (message "found: %s" found))
              (finally-return found))

       ;; => 2
       ;; Messages "found: 2" in echo area.
       (loopy (list i '(1 2 3))
              (finding found i (= i 2))
              (finally-do (message "found: %s" found))
              (finally-return found))

       ;; => "not found"
       (loopy (list i '(1 2 3))
              (finding whether-found i (> i 4) :on-failure "not found")
              (finally-return whether-found))
     #+END_SRC

   #+findex: max, maximize
   - =(max|maxing|maximize|maximizing VAR EXPR)= :: Repeatedly set =VAR= to the
     greater of the values =VAR= and =EXPR=.  =VAR= starts at =-1.0e+INF=, so
     that any other value should be greater that it.

     #+BEGIN_SRC emacs-lisp
       ;; => 11
       (loopy (list i '(1 11 2 10 3 9 4 8 5 7 6))
              (max my-max i)
              (finally-return my-max))
     #+END_SRC

   #+findex: min, minimize
   - =(min|minning|minimize|minimizing VAR EXPR)= :: Repeatedly set =VAR= to the
     lesser of the values =VAR= and =EXPR=.  =VAR= starts at =1.0e+INF=, so that
     any other value should be less than it.

     #+BEGIN_SRC emacs-lisp
       ;; => 0
       (loopy (list i '(1 11 2 10 3 0 9 4 8 5 7 6))
              (min my-min i)
              (finally-return my-min))
     #+END_SRC

   #+findex: multiply, multiplying
   - =(multiply|multiplying VAR EXPR)= :: Repeatedly set =VAR= to the product of
     the values =EXPR= and =VAR=.  =VAR= starts at 1.

     #+BEGIN_SRC emacs-lisp
       ;; => 120
       (loopy (list i '(1 2 3 4 5))
              (multiply 5-factorial i)
              (finally-return 5-factorial))
     #+END_SRC
     
   #+findex: nconc
   - =(nconc|nconcing VAR EXPR &key at)= :: Repeatedly concatenate the value of
     =EXPR= onto =VAR= as if via the function ~nconc~.

     #+attr_texinfo: :tag Caution
     #+begin_quote
     ~nconc~ is a destructive operation that modifies =VAR= directly
     ([[info:elisp#Rearrangement]]).  This is important to keep in mind when working
     with literal values, such as the list ='(1 2 3)=, whose modification could
     apply wherever that value is used ([[info:elisp#Self-Evaluating Forms]]).
     #+end_quote

     #+BEGIN_SRC emacs-lisp
       ;; => '(1 2 3 4 5 6 7 8)
       (loopy (list i '((1 2 3 4) (5 6 7 8)))
              (nconc my-new-list i)
              (finally-return my-new-list))

       ;; => '(3 3 3 2 2 1)
       (loopy (list i (list (make-list 1 1)
                            (make-list 2 2)
                            (make-list 3 3)))
              (nconc i :at start))
     #+END_SRC

   #+findex: nunion
   - =(nunion|nunioning VAR EXPR &key test key at)= :: Repeatedly and
     /destructively/ insert into =VAR= the elements of =EXPR= which are not
     already present in =VAR=.

     #+begin_src emacs-lisp
       ;; => (4 1 2 3)
       (loopy (list i '((1 2) (2 3) (3 4)))
              (nunion var i)
              (finally-return var))

       ;; => ((a . 2))
       (loopy (array i [((a . 1)) ((a . 2))])
              (nunioning var i :key #'car)
              (finally-return var))

       ;; => (4 2 (1 1) 3)
       (loopy (list i '(((1 1) 2) ((1 1) 3) (3 4)))
              (nunioning var i :test #'equal)
              (finally-return var))

       ;; => ((1 2 3) (2 3 4))
       (loopy (array i [((1 2) (2 3))
                        ((1 2 3) (3 4))])
              (nunion (var1 var2) i :test #'equal)
              (finally-return var1 var2))

       ;; => ((4 2) (1 2) (3 2))
       (loopy (list i '(((1 2) (3 2)) ((1 1) (4 2))))
              (nunion i :at start :key #'car))
     #+end_src

   #+findex: prepend
   - =(prepend|prepending VAR EXPR)= :: Repeatedly concatenate =EXPR= onto the
     front of =VAR=.

     This command is equivalent to =(append VAR EXPR :at start)=.  It exists
     for clarity and convenience.

     #+begin_src emacs-lisp
       ;; => (5 6 3 4 1 2)
       (loopy (array i [(1 2) (3 4) (5 6)])
              (prepend i))

       ;; => (4 3 2 1)
       (let ((my-list '(1)))
         (loopy (without my-list)
                (array elem [(2) (3) (4)])
                (prepend my-list elem)
                (finally-return my-list)))
     #+end_src

   #+findex: push, push-into
   - =(push|push-into|pushing|pushing-into VAR EXPR)= :: Collect the value of
     =EXPR= into a list, adding values to the front of =VAR= as if via the
     function ~push~.

     This command is equivalent to =(collect VAR EXPR :at start)=.  It exists
     for clarity and convenience.

     #+BEGIN_SRC emacs-lisp
       ;; => (3 2 1)
       (loopy (array i [1 2 3])
              (push my-list i)
              (finally-return my-list))
     #+END_SRC

   #+findex: reduce
   - =(reduce|reducing VAR EXPR FUNC &key init)= :: Reduce =EXPR= into =VAR= via
     =FUNC=.  =FUNC= is called with =VAR= as the first argument and =EXPR= as
     the second argument.  This is unlike =accumulate=, which gives =VAR= and
     =EXPR= to =FUNC= in the opposite order (i.e., =EXPR= first, then =VAR=).

     =VAR= is initialized to =INIT=, if provided, or ~nil~.

     This command is similar in effect to the =expr= command.

     #+begin_src emacs-lisp
       ;; = > 6
       (loopy (list i '(1 2 3))
              (reduce my-reduction i #'+ :init 0)
              (finally-return my-reduction))

       ;; Works similarly to above:
       (loopy (list i '(1 2 3))
              (set my-reduction (+ i my-reduction) :init 0)
              (finally-return my-reduction))

       ;; => 24
       (loopy (list i '(1 2 3 4))
              (reduce i #'* :init 1))
     #+end_src

     This command also has the alias =callf=.  It is similar to using the
     function ~cl-callf~, except that the function argument is given last and
     must be quoted.  This alias is intended to help users remember argument
     order.

     #+begin_src emacs-lisp
       (loopy (list i '(1 2 3))
              (callf my-reduction i #'+ :init 0)
              (finally-return my-reduction))

       ;; Is similar to the above:
       (loopy (with (my-reduction 0))
              (list i '(1 2 3))
              (do (cl-callf + my-reduction i))
              (finally-return my-reduction))
     #+end_src

   #+findex: sum
   - =(sum|summing VAR EXPR)= :: Repeatedly set =VAR= to the sum of the values
     of =EXPR= and =VAR=.  =VAR= starts at 0.

     #+BEGIN_SRC emacs-lisp
       ;; => 10
       (loopy (list i '(1 2 3 4))
              (sum my-sum i)
              (finally-return my-sum))
     #+END_SRC

   #+findex: union
   + =(union|unioning VAR EXPR &key test key at)= :: Repeatedly insert into
     =VAR= the elements of the list =EXPR= which are not already present in
     =VAR=.

     #+begin_src emacs-lisp
       ;; => (4 1 2 3)
       (loopy (list i '((1 2) (2 3) (3 4)))
              (union var i)
              (finally-return var))

       ;; => ((a . 2))
       (loopy (array i [((a . 1)) ((a . 2))])
              (unioning var i :key #'car)
              (finally-return var))

       ;; => (4 2 (1 1) 3)
       (loopy (list i '(((1 1) 2) ((1 1) 3) (3 4)))
              (unioning var i :test #'equal)
              (finally-return var))

       ;; => ((1 2 3) (2 3 4))
       (loopy (array i [((1 2) (2 3))
                        ((1 2 3) (3 4))])
              (union (var1 var2) i :test #'=)
              (finally-return var1 var2))

       ;; => ((4 2) (1 2) (3 2))
       (loopy (list i '(((1 2) (3 2)) ((1 1) (4 2))))
              (union var i :at 'start :key #'car)
              (finally-return var))
     #+end_src

   #+findex: vconcat
   - =(vconcat|vconcating VAR EXPR)= :: Repeatedly concatenate the value of
     =EXPR= onto =VAR= via the function ~vconcat~.  For concatenating values
     onto a string, see the command =concat=.

     =VAR= is a vector throughout the loop.  This differs from the behavior of
     commands with the keyword argument =result-type=, which coerces the
     resulting sequence of accumulated values into a new type /after/ the loop
     completes.

     #+BEGIN_SRC emacs-lisp
       ;; => [1 2 3 4 5 6]
       (loopy (list i '([1 2 3] [4 5 6]))
              (vconcat my-vector i)
              (finally-return my-vector))

       ;; => [4 5 6 1 2 3]
       (loopy (list i '([1 2 3] [4 5 6]))
              (vconcat i :at 'start))
     #+END_SRC


*** Stack-Based Accumulations
:PROPERTIES:
:CUSTOM_ID: stack-accumulations
:DESCRIPTION: Treating accumlation variables like a stack or queue.
:END:

These commands technically don't accumulate values, but are purposefully made to
be able to efficiently edit the accumulation variables.  These commands are
always optimized given the settings of the other accumulation commands used.

#+findex: drop, pop
- =(drop|pop VAR NUMBER &key pos)= :: Remove the first or last =NUMBER= items
  from =VAR=, depending on the value of =POS=.  This command is similar to the
  functions ~seq-drop~ or ~pop~, but can work on the beginning or end of the
  variable.  Like those functions, it defaults to operating on the front of the
  variable.

  As with other accumulation commands, the value =NUMBER= can be a variable
  whose value changes during the loop.

  #+begin_src emacs-lisp
    ;; => (4 5 6 7 8 9)
    (loopy (with (N 1))
           (array i [(1 2 3) (4 5 6) (7 8 9)])
           (append i :at end)
           (drop N :at start))

    ;; (5 6 7)
    (loopy (array i [(1 2 3) (3 4 5) (5 6 7)])
           (append coll i :at start)
           (drop coll 2 :at end)
           (finally-return coll))

    ;; => [5 6 7 4 5 1]
    (loopy (accum-opt (coll start))
           (list i '((1 2 3 3) [4 5] (5 6 7)))
           (set count (1+ count) :init 0)
           (vconcat coll i :at start)
           (when (eq count 2)
             (pop coll 3 :at end))
           (finally-return coll))
  #+end_src

#+findex: drop-while
- =(drop-while|pop-while VAR PREDICATE &key pos)= :: Remove items
  from the start or end of =VAR= while =PREDICATE= is true.  This command is
  similar to the function ~seq-drop-while~, but can work on the beginning or end
  of the variable.  Like those functions, it defaults to operating on the front
  of the variable.

  As with other accumulation commands, the function =PREDICATE= should be
  quoted.  In this command, it is a function taking the tested element as its
  first argument.

  #+begin_src emacs-lisp
    ;; => ((4 5)
    ;;     ((1 1 2) (2 2 3) (3 3 4 5)))
    (loopy (list i '((1 1 2) (2 3) (3 4 5)))
           (append coll1 i)
           (collect coll2 (copy-sequence coll1))
           (if (cl-evenp (car coll1))
               (drop-while coll1 #'cl-evenp)
             (drop-while coll1 #'cl-oddp))
           (finally-return coll1 coll2))
  #+end_src

***  Optimizing Accumulations
:PROPERTIES:
:CUSTOM_ID: optimized-accums
:DESCRIPTION: Producing efficient accumulations
:END:

#+cindex: optimizing accumulations
By default, named accumulation variables (excluding the automatically named
~loopy-result~) are accessible during the loop, and their values are always
correct during execution.  For example, lists are always in the correct order,
even when constructing linked lists in the reverse order would be more
efficient.

#+begin_src elisp
  ;; Note how `coll' is always in the correct order:
  ;; => ((1 2 3)
  ;;     ((1) (1 2) (1 2 3)))
  (loopy (array i [1 2 3])
         (collect coll i)
         (collect intermediate-values (copy-sequence coll))
         (finally-return coll intermediate-values))
#+end_src

Implied accumulation variables do not have the requirement of always being in
the correct order, so commands using such variables can produce more efficient
code.

#+begin_src emacs-lisp
  ;; Similar in efficiency to the below:
  ;; => (2 3 4 5 6 7 8 9 10 11 12 13 ...)
  (loopy (list i (number-sequence 1 1000))
         (collect (1+ i)))

  ;; => (2 3 4 5 6 7 8 9 10 11 12 13 ...)
  (let (result)
    (dolist (i (number-sequence 1 1000))
      (push (1+ i) result))
    (nreverse result))
#+end_src

The situation becomes more complex when commands place values at both sides of a
sequence.  In that case, ~loopy~ keeps track of the beginning /and/ the end
of the sequence.  ~loopy~ does /not/ merely append to the end of the resulting
list, since that would be much slower for large lists.

#+begin_src emacs-lisp
  ;; `loopy' can be faster than the below `dolist' approach:
  ;; => (3 2 1 7 14 21)
  (loopy (list i '(1 2 3))
         (collect i :at start)
         (collect (* i 7) :at end))

  ;; For large accumulations, this is slower than the above:
  ;; => (3 2 1 7 14 21)
  (let (result)
    (dolist (i '(1 2 3))
      (setq result (cons i result)
            result (nconc result (list (* i 7)))))
    result)
#+end_src

In such cases, ~loopy~ will naively optimize placing values at whichever side
appears to be the most used.  In the example below, note that even though the
commands to insert values at the front of the list are never actually run,
~loopy~ will still optimize for frontal insertions.  Here, ~loopy~ simply counts
that 2 commands seem to place values at the front of the list while only 1
command seems to place values at the end.

#+begin_src emacs-lisp
  ;; This code optimizes for insertions at the front of the list:
  ;; => (1 2 3)
  (loopy (list i '(1 2 3))
         (collect i :at end)
         (when nil
           (collect i :at start)
           (collect i :at start)))
#+end_src

The special macro argument =accum-opt= can be used to better control these
optimizations ([[#macro-arguments]]).  With it, you can (1) treat an explicit
variable as if it were implicit and optionally (2) specify which side of a
sequence you expect to use more.  The arguments passed to =accum-opt= are either
symbols (such as ~loopy-result~) or lists of a symbol and a position.  To be
clear, use of the variable ~loopy-result~ is always at least naively optimized
in the manner described above.

In the example below, see that
1. Accumulation into the named variable ~coll~ has been specifically optimized
   for using the end of the sequence, despite there being more commands that use
   the beginning of the sequence.
2. Because accumulation into ~coll~ has been optimized, the order of values in
   ~coll~ need not be correct during the loop.

#+begin_src emacs-lisp
  ;; This code optimizes for insertions at the end of `coll':
  ;; => ((23 13 22 12 21 11 1 2 3)
  ;;     ((1 11 21) (2 1 11 21 12 22) (3 2 1 11 21 12 22 13 23)))
  (loopy (accum-opt (coll end))
         (list i '(1 2 3))
         (collect coll i :at end)
         (collect coll (+ 10 i) :at start)
         (collect coll (+ 20 i) :at start)
         (collect intermediate-values (copy-sequence coll))
         (finally-return coll intermediate-values))
#+end_src


#+cindex: accum-opt vs. split
The =accump-opt= special macro argument can also be used with destructuring.
Because destructuring requires using named variables, such variables are by
default required to ordered correctly during the loop.  If you do not require
that, you are recommended to use =accum-opt= on those variables.

#+begin_src emacs-lisp
  ;; => ((1 3)
  ;;     (2 4)
  ;;     ((1) (3 1))
  ;;     ((2) (4 2)))
  (loopy (accum-opt a b)
         (array elem [(1 2) (3 4)])
         (collect (a b) elem)
         (collect intermediate-a (copy-sequence a))
         (collect intermediate-b (copy-sequence b))
         (finally-return a b intermediate-a intermediate-b))
#+end_src

The other option, though not exactly the same, is to destructure in iteration
commands and use the =split= flag with accumulations ([[#flags]]).  Both options
remove the sorting requirements on the accumulations variables.

#+begin_src emacs-lisp
  ;; The following two loops are approximately equivalent.

  ;; => ((1 4 7) (2 5 8) (3 6 9))
  (loopy (accum-opt i j k)
         (array elem [(1 2 3) (4 5 6) (7 8 9)])
         (collect (i j k) elem)
         (finally-return i j k))

  ;; => ((1 4 7) (2 5 8) (3 6 9))
  (loopy (flag split)
         (array (i j k) [(1 2 3) (4 5 6) (7 8 9)])
         (collect i)
         (collect j)
         (collect k))
#+end_src

** Boolean
   :PROPERTIES:
   :CUSTOM_ID: boolean-commands
   :DESCRIPTION: Testing whether a condition holds true.
   :END:

   Boolean commands are used to test whether a condition holds true for elements
   of a sequence.  Under certain conditions, they cause the loop to exit and
   return a value.  Like accumulation commands, they have an implicit return
   value which is used if these commands do not cause the loop to exit.

   It is incorrect to use both =thereis= and one of =always= or =never= in the
   same loop, as this leads to conflicting implicit return values.

   For convenience, these commands can be passed multiple conditions.

   #+findex: always
   - =(always COND [CONDS])= :: Immediately return ~nil~ if any =COND= is ever
     ~nil~.  Otherwise, the loop returns the final value of the last =COND= or
     ~t~ if no =COND= is ever evaluated.

     #+BEGIN_SRC emacs-lisp
       ;; => t
       (loopy (list i '(1 0 1 0 1))
              (always (< i 2)))

       ;; => nil
       (loopy (list i '(1 0 1 0 1))
              (always (< i 1)))

       ;; => t
       (loopy (list i '(1 0 1 0 1))
              ;; Note: can accept multiple conditions.
              ;; This is equivalent to `(always (and (< i 2) (>= i 0)))'.
              (always (< i 2) (>= i 0)))

       ;; => "hello"
       (loopy (list i '(1 1 1 1))
              ;; The return value of `(and (< i 2) "hello")' is "hello".
              (always (< i 2) "hello"))

       ;; NOTE: Here, the implicit return value is `t' because an
       ;;       `always' command was used, and that return value
       ;;       is never updated to "hello" because the `always'
       ;;       command is never actually used.
       ;;
       ;; => t
       (loopy (list i '(1 1 1 1))
              (when nil
                (always (> i 5) "hello")))
     #+END_SRC
   
   #+findex: never
   - =(never COND [CONDS])= :: Immediately return ~nil~ if any =COND= is ever
     non-nil.  Otherwise, the loop returns ~t~.

     #+BEGIN_SRC emacs-lisp
       ;; => t
       (loopy (list i '(1 0 1 0 1))
              (never (= i 3)))

       ;; => nil
       (loopy (list i '(1 0 1 0 1))
              (never (= i 0)))

       ;; Like `always', `never' can also accept multiple arguments. They are
       ;; treated as `(never (or COND1 COND2 ... CONDN))'.

       ;; => t
       (loopy (list i '(1 0 1 0 1))
	      ;; equivalent to `(never (or (= i 3) (= i 4)))'.
              (never (= i 3) (= i 4)))
     #+END_SRC

     =never= does not affect the loop's implicit return value when using the
     =always= command.

     #+begin_src emacs-lisp
       ;; This example taken from the documentation of CL's Iterate package.
       ;;
       ;; => 2, not t
       (loopy (cycle 2)
              (always 2)
              (never nil))
     #+end_src
     
   #+findex: thereis
   - =(thereis COND [CONDS])= :: Immediately return the value of =COND= if said
     value is ever non-nil.  Otherwise, the loop returns ~nil~.  If more than
     one condition is specified, then they are treated as one condition joined
     by ~and~.

     #+BEGIN_SRC emacs-lisp
       ;; => 3
       (loopy (list i '(1 0 1 3 1))
              ;; Note: `and' returns the last value it evaluates.
              (thereis (and (> i 2) i)))

       ;; => nil
       (loopy (list i '(1 0 1 0 1))
              (thereis (and (> i 2) i)))

       ;; => nil
       (loopy (list i '(1 0 1 0 1))
	      ;; Same as above. Like `always' uses an explicit `and'.
              (thereis (> i 2) i))

       ;; => 3
       (loopy (list i '(nil nil 3 nil))
              (thereis i))
     #+END_SRC


** Control Flow
   :PROPERTIES:
   :CUSTOM_ID: control-flow
   :DESCRIPTION: When to run loop commands.
   :END:

*** Conditionals
    :PROPERTIES:
    :CUSTOM_ID: conditionals
    :DESCRIPTION: Choosing if commands should run.
    :END:

    Conditional commands in ~loopy~ can take multiple sub-commands, and work
    like their Lisp counterparts.  There is therefore no need for an =and=
    command as used in ~cl-loop~.

    #+findex: when
    - =(when EXPR CMDS)= :: Run =CMDS= only if =EXPR= is non-nil.

      #+BEGIN_SRC emacs-lisp
        ;; Get only the inner lists with all even numbers.
        ;; => '((2 4 6) (8 10 12) (16 18 20))
        (loopy (list i '((2 4 6) (8 10 12) (13 14 15) (16 18 20)))
               (when (loopy (list j i)
                            (always (cl-evenp j)))
                 (collect only-evens i))
               (finally-return only-evens))
      #+END_SRC

    #+findex: if
    - =(if EXPR CMDS)= :: Run the first command if =EXPR= is non-nil.
      Otherwise, run the remaining commands.

      #+BEGIN_SRC emacs-lisp
        ;; => '((1 3 5 7) (2 4 6) (3 3 3))
        (loopy (seq i [1 2 3 4 5 6 7])
               (if (cl-oddp i)
                   (collect odds i)
                 (collect evens i)
                 (collect some-threes 3))
               (finally-return odds evens some-threes))
      #+END_SRC

    #+findex: cond
    - =(cond [(SET CMDS) [...]])= :: Run the commands =CMDS= following the
      first non-nil condition =EXPR=.

      #+BEGIN_SRC emacs-lisp
        ;; => '((2 4 6) (1 3 5) ("cat" "dog"))
        (loopy (list i '(1 2 3 "cat" 4 5 6 "dog"))
               (cond
                ((not (numberp i)) (collect not-numbers i))
                ((cl-evenp i)      (collect evens i))
                (t                 (collect odds i)))
               (finally-return evens odds not-numbers))
      #+END_SRC

*** Skipping Cycles
    :PROPERTIES:
    :CUSTOM_ID: skipping-an-iteration
    :DESCRIPTION: Immediately beginning the next iteration.
    :END:

    #+findex: skip, continue
    - =(skip|continue)= :: Go to the next loop iteration.

      #+BEGIN_SRC emacs-lisp
        ;; => (2 4 6 8 12 14 16 18)
        (loopy (seq i (number-sequence 1 20))
               (when (zerop (mod i 10))
                 (skip))
               (when (cl-evenp i)
                 (push-into my-collection i))
               (finally-return (nreverse my-collection)))
      #+END_SRC

    #+findex: skip-from, continue-from
    - =(skip-from|continue-from NAME)= :: Go to the next loop iteration of the
      loop =NAME=.

      #+BEGIN_SRC emacs-lisp
        ;; => ((1 2 3) (7 8 9))
        (loopy outer
               (array i [(1 2 3) (4 5 6) (7 8 9)])
               (loop (list j i)
                     (if (= 5 j)
                         (skip-from outer)))
               (collect i))
      #+END_SRC


*** Early Exit
    :PROPERTIES:
    :CUSTOM_ID: exiting-the-loop-early
    :DESCRIPTION: Leaving the loop early, with or without returning values.
    :END:

    The loop is contained in a ~cl-block~, which can be exited by the function
    ~cl-return-from~.  Indeed, the =return= and =return-from= commands are just
    wrappers around that function.

    As with the =finally-return= special macro argument, passing multiple return
    values to those commands will return a list of those values.  If no value is
    given, ~nil~ is returned.

    The commands =leave=, =leave-from=, =while=, and =until= leave the current
    loop without forcing a returned value.  Unlike the =return= commands, they
    do not stop the loop from returning any implied return values, such as the
    collections in their respective examples.

    #+findex: leave
    - =(leave)= :: Leave the current loop without forcing a return value.

      #+begin_src emacs-lisp
        ;; => (1 2 3 4)
        (loopy (list i '(1 2 3 4 5 6 7))
               (if (= i 5)
                   (leave)
                 (collect i)))
      #+end_src

    #+findex: leave-from
    - =(leave-from NAME)= :: Leave the loop =NAME= without forcing a return
      value.  This command is equivalent to =(at NAME (leave))= ([[#sub-loops]]).

      #+begin_src emacs-lisp
        ;; => ([2 4] [6 8])
        (loopy outer
               (list i '([2 4] [6 8] [7 10]))
               (sub-loop (array j i)
                         (when (cl-oddp j)
                           ;; Equivalent to `(at outer (leave))'
                           (leave-from outer)))
               (collect i))
      #+end_src

    #+findex: return loop command
    - =(return [EXPRS])= :: Leave the current loop, returning =[EXPRS]=.

      #+BEGIN_SRC emacs-lisp
        ;; => 6
        (loopy (with  (j 0))
               (do (cl-incf j))
               (when (> j 5)
                 (return j)))
      #+END_SRC

    #+findex: return-from
    - =(return-from NAME [EXPRS])= :: Leave the loop =NAME=, returning =[EXPRS]=.

      #+BEGIN_SRC emacs-lisp
        ;; => 'bad-val?
        (loopy outer-loop
               (list inner-list '((1 2 3) (1 bad-val? 1) (4 5 6)))
               (sub-loop (list i inner-list)
                         (when (eq i 'bad-val?)
                           (return-from outer-loop 'bad-val?))))
      #+END_SRC

    #+findex: while
    - =(while COND)= :: Leave the loop once =COND= is false, without forcing a
      return value.  =(while COND)= is the same as =(until (not COND))=.

      #+begin_src emacs-lisp
        ;; => (1 2 3 4)
        (loopy (list i '(1 2 3 4 5 6 7))
               (while (not (= i 5)))
               (collect i))
      #+end_src

    #+findex: until
    - =(until COND)= :: Leave the loop once =COND= is true, without forcing a
      return value.  =(until COND)= is the same as =(while (not COND))=.

      #+begin_src emacs-lisp
        ;; => (1 2 3 4)
        (loopy (list i '(1 2 3 4 5 6 7))
               (until (= i 5))
               (collect i))
      #+end_src

** Sub-Loops
   :PROPERTIES:
   :DESCRIPTION: Running a loop within a loop.
   :CUSTOM_ID: sub-loops
   :END:

   The following commands exist to properly handle sub-loops.  Depending on
   one's needs, trying to use a ~loopy~ macro call inside the =do= command could
   signal an error.  This is because arguments of the =do= command are inserted
   literally (i.e., without interpretation or modification) into the expanded
   code.  This means that using ~loopy~ inside the =do= command cannot affect
   any of the super-loop's generated code, such as variable declarations.  The
   following commands do not have that problem, because their expansions are
   processed during the expansion of the top-level macro.

   #+begin_src emacs-lisp
     ;; Raises an error:
     (loopy outer
            (list i '((1 2) (3 4) (5 6)))
            (do (loopy (list j i)
                       (when (= j 5)
                         (leave-from outer))))
            (collect i))

     ;; Works as expected:
     ;; => ((1 2) (3 4))
     (loopy outer
            (list i '((1 2) (3 4) (5 6)))
            (sub-loop (list j i)
                      (when (= j 5)
                        (leave-from outer)))
            (collect i))
   #+end_src


   #+findex: sub-loop, subloop, loop
   - =(sub-loop|subloop|loop [SPECIAL-MACRO-ARGUMENTS] [CMDS])= :: Create a
     sub-loop in the same lexical environment as the top-level loop, processing
     sub-commands during the top-level loop's expansion.

     This command is a wrapped form of the ~loopy~ macro, and so supports all of
     its features, including special macro arguments.  When using ~loopy-iter~
     ([[#loopy-iter]]), this command wraps the ~loopy-iter~ macro instead.

     #+begin_src emacs-lisp
       ;; => ((2 4) (6 8) (10 12))
       (loopy outer
              (array i [(2 4) (6 8) (1 3) (10 12)])
              (sub-loop (list j i)
                        (when (cl-oddp j)
                          (skip-from outer)))
              (collect i))
     #+end_src

   #+findex: at
   - =(at LOOP-NAME [CMDS])= :: Parse some commands with respect to =LOOP-NAME=.
     For example, a =leave= subcommand would exit the loop =LOOP-NAME=, and an
     accumulation command would create a variable in that super-loop.

     If one did not use =at= in the below example, then the accumulation would
     be local to the sub-loop and the macro's return value would be ~nil~.

     #+begin_src emacs-lisp
       ;; => (4 5 10 11 16 17)
       (loopy outer
              (array i [(1 2) (3 4) (5 6)])
              (sub-loop (with (sum (apply #'+ i)))
                        (list j i)
                        (at outer (collect (+ sum j)))))
     #+end_src

   #+findex: loopy command
   - =(loopy [SPECIAL-MACRO-ARGUMENTS] [CMDS])= :: Specifically wrap a call to
     the ~loopy~ macro.  Unlike the =sub-loop= command, the behavior of this
     command never changes.

     Don't confuse using this command with using calls to the macro ~loopy~.
     For example, the =EXPR= parameter to loop commands is used literally, and
     is not able to affect macro expansion.  Therefore, the warning at the start
     of this section applies to =EXPR= parameters as well.  This is demonstrated
     in the example below.

     #+begin_src emacs-lisp
       (loopy outer
              (list i '(1 2 3))
              ;; This is the macro `loopy', not the loop command.
              ;; Therefore, the warning about macro expansion applies,
              ;; and this signals an error.
              (when (loopy (at outer (collect i))
                           (leave))
                (do nil)))
     #+end_src

   #+findex: loopy-iter command
   - =(loopy-iter [SPECIAL-MACRO-ARGUMENTS] [BODY])= :: Specifically wrap a call
     to the ~loopy-iter~ macro ([[#loopy-iter]]).  Unlike the =sub-loop= command,
     the behavior of this command never changes.

     This feature can only be used after first loading the library =loopy-iter=.

     #+begin_src elisp
       (require 'loopy-iter)

       ;; => '(11 12 13 14 15 16)
       (loopy outer
              (list i '((1 2) (3 4) (5 6)))
              (loopy-iter (for list j i)
                          (for at outer
                               (let ((val 10))
                                 (accum collect (+ val j))))))
     #+end_src


   Keep in mind that the effects of flags ([[#flags]]) are local to the loops in
   which they are used, even when using the =at= command.

   #+begin_src emacs-lisp
     ;; => ((1 2 11 12)
     ;;     ((2) (3) (12) (13)))
     (loopy outer
            (flag pcase)
            (array elem [(1 2) (11 12)])
            (collect `(,first . ,rest) elem)
            ;; NOTE: The sub-loop uses the default destructuring style.
            ;;       The `pcase' style only affects the surrounding loop.
            (sub-loop (at outer (collect (first &rest rest) (mapcar #'1+ elem)))
                      (leave))
            (finally-return first rest))

     ;; => (((1 2) (3 4))
     ;;     (cat cat)
     ;;     (1 dog 2 dog 3 dog 4 dog))
     (loopy outer
            (flag split)
            (list i '((1 2) (3 4)))
            (collect i)
            (collect 'cat)
            (loop (list j i)
                  ;; NOTE: These variables not split.
                  (at outer
                      (collect j)
                      (collect 'dog))))
   #+end_src


* Special Variables
  :PROPERTIES:
  :CUSTOM_ID: special-vars
  :END:

  Beyond loop commands, there is one special variable that can be used inside of
  the loop.

  #+vindex: loopy-first-iteration
  - =loopy-first-iteration= :: Whether the current loop is in its first
    iteration.

    #+attr_texinfo: :tag Warning
    #+begin_quote
    You should not attempt to set this variable, as it is used by some loop
    commands.
    #+end_quote


* Destructuring Macros
  :PROPERTIES:
  :CUSTOM_ID: destr-macros
  :DESCRIPTION: Destructuring outside of the loop.
  :END:

  Loopy's built-in destructuring functionality can also be used via the listed
  macros below.  These macros are /not/ affected by flags which configure
  destructuring ([[#flags]]), as equivalent features are already provided by those
  libraries.

  These macros can be used anywhere, not just inside calls to ~loopy~.

  #+findex: loopy-let*
  - ~loopy-let*~ :: Use destructuring in a ~let~ form, similar to ~pcase-let~
    and ~seq-let~.

    #+begin_src emacs-lisp
      ;; => (1 2 3 4 5 28)
      (loopy-let* ((a 1)
                   ([b c] [2 3])
                   ((&keys k1 k2 (k3 28)) '(:k1 4 :k2 5)))
        (list a b c k1 k2 k3))
    #+end_src

  #+findex: loopy-setq
  - ~loopy-setq~ :: Use destructuring in a ~setq~ form.

    #+begin_src emacs-lisp
      ;; => (1 2 3 4 5 28)
      (let (a b c k1 k2 k3)
        (loopy-setq a 1
                    [b c] [2 3]
                    (&keys k1 k2 (k3 28)) '(:k1 4 :k2 5))
        (list a b c k1 k2 k3))
    #+end_src

  #+findex: loopy-lambda
  - ~loopy-lambda~ :: Use destructuring in a ~lambda~'s argument list.

    #+begin_src emacs-lisp
      ;; => ((1 2 :k1 3) 110)
      (funcall (loopy-lambda ((&whole first-arg a b &key k1 (k2 4))
                              second-arg)
                 (list first-arg (+ a b k1 k2 second-arg)))
               (list 1 2 :k1 3) 100)
    #+end_src

  #+findex: loopy-ref
  - ~loopy-ref~ :: Create destructured references to the fields in a sequence
    via ~cl-symbol-macrolet~.  This is not to be confused with ~cl-letf~, which
    temporarily binds those places to a value.

    This macro exposes the destructuring used in the sequence reference
    iteration commands ([[#sequence-reference-iteration]]).  There are some
    limitations to this functionality in Emacs Lisp, which are described in that
    section.

    #+begin_src emacs-lisp
      ;; => ((20 2 23) [24 25 26])
      (let ((l1 (list 1 2 3))
            (a1 (vector 4 5 6)))
        (loopy-ref (((a _ b) l1)
                    ([c &rest d] a1))
          (setf a 20
                b 23
                c 24
                d [25 26]))
        (list l1 a1))
    #+end_src

  
* The ~loopy-iter~ Macro
:PROPERTIES:
:CUSTOM_ID: loopy-iter
:DESCRIPTION: Embedding loop commands in arbitrary code.
:END:

#+cindex: loopy-iter
#+findex: loopy-iter
~loopy-iter~ is a macro that allows for the embedding of loop commands inside
arbitrary code.  This is different from the =do= loop command, with which one
can embed arbitrary code in a loop.  You must use ~require~ to load this
feature.

#+attr_texinfo: :tag Warning
#+begin_quote
*This feature is still experimental.*  It might not work correctly in all
circumstances.  Please report any problems you come across on this project's
[[https://github.com/okamsn/loopy/issues][issues tracker]].
#+end_quote

This macro is meant to be conceptually similar to the ~iterate~ or ~iter~
macro provided by the Common Lisp package "Iterate" [fn:iter] (not to be
confused with the ~iter-*~ functions provided by Emacs).

#+begin_src emacs-lisp
  (require 'loopy-iter) ; <- Must `require' to load feature.

  ;; => (2 4 6)
  (loopy-iter (for list i '(1 2 3))
              (let ((a (* 2 i)))
                (accum collect a)))
#+end_src

#+cindex: loopy-iter keywords
#+vindex: loopy-iter-command-keywords
To clearly distinguish between loop commands and Emacs features (such as
between the loop command =list= and the function ~list~), a loop command must
be preceded by one of the keywords listed in ~loopy-iter-command-keywords~.
By default, this is one of =for=, =accum=, or =exit=.  These keywords do not
share a name with any built-in Emacs feature and are similar to the keywords
used by other packages.  For example, =(list VAR LIST)= would be =(for list
VAR LIST)= or =(for in VAR LIST)=.

Any keyword in the user option ~loopy-iter-command-keywords~ can be used to
identify any loop command.  For example, =(accum collect a)= and
=(for collect a)= are both valid ways of referring to the =collect= loop
command in ~loopy-iter~.

To disable this requirement, use the flag =lax-naming= ([[#flags][Using Flags]]).  When
using =lax-naming=, ~loopy-iter~ will always prefer built-in features to loop
commands.  For example, "list" will always be understood as referring to the
function ~list~ and not the loop command =list=.

Special macro arguments, already having clearly distinguishable names, do not
need to be preceded by one of the above keywords.

#+cindex: Ignoring names in loopy-iter
#+vindex: loopy-iter-ignored-names
That being said, the names of some ~loopy~ features /can/ cause conflicts, such
as the alias =let*= for the special macro argument =with=.  To ignore these
names, list them in the user option ~loopy-iter-ignored-names~.  The symbol
=let*= is included by default.

This user option always applies to special macro arguments.  It only applies to
loop commands when =lax-naming= is enabled.

#+begin_src emacs-lisp
  ;; => ((1 8) (2 9) (3 10))
  (loopy-iter (with (a 7))                ; <- Set once around loop.
              (for list elem '(1 2 3))
              (let* ((c elem)             ; <- These set inside of loop.
                     (d (+ a c)))
                (accum collect (list c d))))
#+end_src

Restrictions on the placement of loop commands and special macro arguments
still apply in ~loopy-iter~.  For example, iteration commands must still occur
at the top level of ~loopy-iter~ or a sub-loop.

#+begin_src emacs-lisp
  ;; BAD
  (loopy-iter (let ((a (progn
                         ;; ERROR: `list' must occur at top level.
                         (for list j '(8 9 10 11 12))
                         j)))
                (accum collect a)))

  ;; GOOD
  ;; => (8 9 10 11 12)
  (loopy-iter (let ((a (progn
                         ;; NOTE: No restriction on placement of `expr'.
                         (for expr j 8 (1+ j))
                         ;; Leave loop but don't force return value,
                         ;; allowing the implicit result to be returned.
                         (exit until (> j 12))
                         j)))
                (accum collect a)))
#+end_src

#+attr_texinfo: :tag Caution
#+begin_quote
You should not reply on the value of a loop command's expanded code.  Such
expanded code is an implementation detail and subject to change.
#+end_quote

For convenience, ~loopy-iter~ will not attempt to interpret loop commands in
quoted code, except in sharp-quoted ~lambda~ forms.  This is because the
~lambda~ macro is self-quoting, and so Emacs might quote the form before it is
seen by ~loopy-iter~.

#+begin_src emacs-lisp
  ;; => (1 2 3)
  (loopy-iter (for list elem '(1 2 3))
              (funcall (lambda (x)
                         (accum collect x))
                       elem))

  ;; => (1 2 3)
  (loopy-iter (for list elem '(1 2 3))
              (funcall #'(lambda (x) ; <- sharp-quoted, but still interpreted
                           (accum collect x))
                       elem))
#+end_src

In ~loopy~, the =sub-loop= command is a full ~loopy~ loop ([[#sub-loops]]).  In
~loopy-iter~, it is a full ~loopy-iter~ loop.

#+begin_src emacs-lisp
  ;; => (2 3 4 5)
  (loopy-iter outer
              (for list i '([1 2] [3 4]))
              (for loop
                   ;; NOTE: `loopy-iter' style, not `loopy' style
                   (for array j i)
                   (for at outer
                        (let ((val (1+ j)))
                          (accum collect val)))))
#+end_src

If you do not want this, you can specifically use a full ~loopy~ loop using
the loop command ~loopy~ instead, as in =(for loopy)=.

#+attr_texinfo: :tag Note
#+begin_quote
Nesting arbitrary code in the loop requires knowing how to understand the
code.  You might find cases where ~loopy-iter~ interprets code incorrectly.

Please report such cases on this project's [[https://github.com/okamsn/loopy/issues][issues tracker]].
#+end_quote

~loopy~ (and so ~loopy-iter~) does not currently have all of the features of
Common Lisp's ~iter~ macro.  Think of it more as an alternative form of
~loopy~ instead of a port of ~iter~.


* Using Flags
  :PROPERTIES:
  :CUSTOM_ID: flags
  :DESCRIPTION: Using flags to change behavior.
  :END:

  #+cindex: flag
  A "flag" is a symbol passed to the =flag= or =flags= special macro argument,
  changing the macro's behavior.  Currently, flags affect what method ~loopy~
  uses to perform destructuring (=pcase=, =seq=, =dash=, or the default) and
  whether accumulation commands that don't specify a variable (such as =(collect
  collect-value)=) accumulate into one or several variables.

  Flags are applied in order.  If you specify =(flags seq pcase)=, then ~loopy~
  will use ~pcase-let~ for destructuring, not ~seq-let~.

  #+vindex: loopy-default-flags
  If you wish to always use a flag, you can add that flag to the list
  ~loopy-default-flags~.  These can be overridden by any flag given in the
  =flag= special macro argument.

  The following flags are currently supported:

  #+cindex: pcase flag
  - =pcase= :: Use ~pcase-let~ for destructuring
    ([[info:elisp#Destructuring with pcase Patterns]]).
  #+cindex: seq flag
  - =seq= :: Use ~seq-let~ for destructuring ([[info:elisp#seq-let]]).
  #+cindex: dash flag
  - =dash= :: Use the style of destructuring found in the =dash= library
   ([[info:dash#-let]]).
  #+cindex: split flag
  - =split= :: Make accumulation commands with implicit variables accumulate into
    separate variables, which are then collected into ~loopy-result~.
  #+cindex: lax-naming flag
  - =lax-naming= :: In ~loopy-iter~, don't require keywords when using loop
    commands ([[#loopy-iter][The ~loopy-iter~ Macro]]).
  #+cindex: default flag
  - =default= :: Use the default behavior for all options.


  For convenience, all flags (except =default=) can be undone by prefixing them
  with =-= (a dash or minus sign), which reverts ~loopy~ to its default
  behavior.

  For example, if you have set ~loopy-default-flags~ to =(dash split)= and wish
  to only use the =split= flag for a loop, you can use either =(flags default
  split)= or, more simply, =(flag -dash)=.  These prefixed flags only apply when
  the unprefixed version is active.  That is, =(flags pcase -dash)= is the same
  as just =(flags pcase)=, regardless of the value of ~loopy-default-flags~, as
  =pcase= destructuring will override all uses of =dash= destructuring as it
  comes later in the list.  Similarly, =(flags -dash dash)= and =(flags -dash
  +dash)= leave =dash= destructuring enabled, and =(flags +dash -dash)= disables
  =dash= destructuring and uses the default behavior.

  #+cindex: loopy-dash
  #+cindex: loopy-pcase
  #+cindex: loopy-seq
  The destructuring flags (=pcase=, =seq=, and =dash=) are separate libraries
  (respectively, =loopy-pcase=, =loopy-seq=, and =loopy-dash=) that must be
  loaded after =loopy=.  Currently, =loopy-dash= is a separate package.

  Below are some example of using the destructuring flags.  These flags affect
  the destructuring of:
  - iteration variables
  - accumulation variables
  - variables bound by the special macro argument =with=

  #+attr_texinfo: :tag Note
  #+begin_quote
  These flags do not affect the destructuring of generalized variables
  (~setf~-able places) as the libraries =pcase.el=, =seq.el=, and =dash.el= do
  not yet provide the required functionality.
  #+end_quote

  #+begin_src emacs-lisp
    ;; => ((1 4)            coll1
    ;;     ((2 3) (5 6))    whole
    ;;     (2 5)            x
    ;;     (3 6))           y
    (require 'loopy-dash)
    (loopy (flag dash)
           (list (i j) '((1 (2 3)) (4 (5 6))))
           (collect coll1 i)
           (collect (whole &as x y) j)
           (finally-return coll1 whole x y))

    ;; => ((1 4) (3 6) 10 20 nil nil)
    (require 'loopy-pcase)
    (loopy (flag pcase)
           (with ((or `[,v1 ,v2] `(,v3 ,v4))
                  [10 20]))
           (list elem '((1 (2 3)) (4 (5 6))))
           (collect `(,a (,_ ,b)) elem)
           (finally-return a b v1 v2 v3 v4))

    ;; => (14 26)
    (require 'loopy-seq)
    (loopy (flag seq)
           (with ([v1 v2] [10 20]))
           (list (i &rest j) '((1 . 2) (3 . 4)))
           (sum sum1 i)
           (sum sum2 j)
           (finally-return (+ sum1 v1) (+ sum2 v2)))
  #+end_src

  As noted in previous sections, the =split= flag can be used to generate more
  efficient code for accumulation commands ([[#accumulation-commands]]).  By making
  stronger guarantees about how accumulation variables can be used, ~loopy~ can
  produce results fasters.

   #+begin_src emacs-lisp
     ;; Both of these example give the same result, but the latter
     ;; can expand into more efficient code.
     ;;
     ;; There is also the `push-into' command, which avoids this problem when
     ;; used with `nreverse'.

     ;; => ((1 4) (2 5) (3 6))
     (loopy (list elem '((1 2 3) (4 5 6)))
            (collect (i j k) elem)
            (finally-return i j k))

     ;; => ((1 4) (2 5) (3 6))
     (loopy (flag split) ; Don't accumulate into same implicit variable.
            (list (i j k) '((1 2 3) (4 5 6)))
            (collect i)
            (collect j)
            (collect k))
   #+end_src

   Below is an example of the =split= flag.

   #+begin_src emacs-lisp
     ;; => (1 2 3 4 5)
     (loopy (flag -split)
            (list i '(1 2 3 4 5))
            (if (cl-oddp i)
                (collect i)
              (collect i))
            ;; This `finally-return' is unneeded.
            (finally-return loopy-result))

     ;; => ((1 3 5) (2 4))
     (loopy (flag split)
            (list i '(1 2 3 4 5))
            (if (cl-oddp i)
                (collect i)
              (collect i))
            ;; This `finally-return' is unneeded.
            (finally-return loopy-result))
   #+end_src


* Custom Aliases
:PROPERTIES:
:CUSTOM_ID: custom-aliases
:DESCRIPTION: How to add one's own aliases.
:END:

#+cindex: custom aliases
An {{{dfn(alias)}}} is another name for a command or special macro argument.
~loopy~ comes with several built-in aliases, such as =string= for the command
=array= or =else= for the special macro argument =after-do=.

| Command or Special Macro Argument | Built-In Aliases           |
|-----------------------------------+----------------------------|
| =array=                           | =string=                   |
| =seq-ref=                         | =sequence-ref=, =seqf=     |
| =after-do=                        | =after=, =else=, =else-do= |


An alias works the same as the original command or special macro argument.
They are provided for clarity and convenience.

#+begin_src emacs-lisp
  ;; => ("a" "b" "c" "d")
  (loopy (array i "abcd")
         (collect (char-to-string i)))

  ;; => ("a" "b" "c" "d")
  (loopy (string i "abcd")
         (collect (char-to-string i)))
#+end_src


#+findex: loopy-defalias
Users can define custom aliases using the macro ~loopy-defalias~, which takes an
alias and a definition as arguments.  These arguments can be quoted or
unquoted.

#+begin_src emacs-lisp
  (loopy-defalias items array)

  ;; => (1 2 3)
  (loopy (items i [1 2 3])
         (collect i))
#+end_src

The definition must exist for the alias to be defined correctly.  Definitions
can themselves be aliases, so long as they are already defined.  In other words,
when aliasing custom commands, you should define the alias /after/ defining the
command ([[#adding-custom-commands]]).

#+begin_src emacs-lisp
  ;; Define an alias for the `items' alias from above:
  (loopy-defalias items2 items)

  ;; => (1 2 3)
  (loopy (items2 i [1 2 3])
         (collect i))
#+end_src

When looking for how to parse a command, ~loopy~ will check aliases before
checking the true names of commands.  Effectively, this means that commands can
be overridden by aliases, though this is discouraged.  Such commands can still
be accessed via their other names.

#+begin_src emacs-lisp
  ;; Define `cons' as an alias of `array':
  (loopy-defalias cons array)

  ;; => (1 2 3)
  (loopy (cons i [1 2 3])
         (collect i))

  ;; ERROR: Can no longer use the original definition:
  (loopy (cons i '(1 2 3))
         (collect i))

  ;; Other names still work:
  ;; => ((1 2 3) (2 3) (3))
  (loopy (conses i '(1 2 3))
         (collect i))
#+end_src


Special macro arguments ([[#macro-arguments][Special Macro Arguments]]) can also be aliased.  Using
an alias does not change the fact that the special macro arguments are parsed
before loop commands.

#+begin_src emacs-lisp
  (loopy-defalias as with)

  ;; => (8 9 10)
  (loopy (as (a 7))
         (list i '(1 2 3))
         (collect (+ i 7)))
#+end_src


#+vindex: loopy-aliases
The macro ~loopy-defalias~ modifies the user option ~loopy-aliases~.  However,
while ~loopy~ is still changing, it is recommended to avoid modifying this
variable directly, as its structure may change in the future.  ~loopy-defalias~
is the forward-compatible way of creating aliases.


* Custom Commands
  :PROPERTIES:
  :CUSTOM_ID: adding-custom-commands
  :DESCRIPTION: Extending `loopy' with personal commands.
  :END:

  This section contains information about how loop commands work and how one can
  add custom commands to ~loopy~.  Two examples are provided.

** Background Info
   :PROPERTIES:
   :CUSTOM_ID: background-info
   :DESCRIPTION: The internals of `loopy'.
   :END:

   #+cindex: instruction, instructions
   The core working of ~loopy~ is taking a loop command and generating code that
   becomes part of a ~while~-loop.  This code is represented by
   {{{dfn(instructions)}}}, which basically describe where and how code is
   inserted into/around a template of a ~while~-loop.

   Some examples of instructions are:
   - Declaring a given variable in a ~let~-like form to make sure it's locally
     scoped.
   - Declaring a generated variable in a ~let~-like form to contain a given
     value.
   - Adding a condition for continuing/exiting the loop.
   - Adding code to be run during the main processing section of the
     ~while~-loop.  This location is referred to as the {{{dfn(main body)}}} of
     the loop.
   - Adding code to be run after the main processing section, such as for
     updating variables.  This location is referred to as the
     {{{dfn(latter body)}}} of the loop.

   For example, parsing the command =(list i '(1 2 3))= produces the following
   list of instructions.  Some commands require the creation of unique temporary
   variables, such as =list-211= in the below output.

   #+BEGIN_SRC emacs-lisp
     ((loopy--iteration-vars (list-211 '(1 2 3)))
      (loopy--iteration-vars (i nil))
      (loopy--pre-conditions (consp list-211))
      (loopy--main-body      (setq i (car list-211)))
      (loopy--latter-body    (setq list-211 (cdr list-211))))
   #+END_SRC

   The first element of an instruction describes where to insert code into the
   template.  The second element of an instruction is the inserted code.  You
   can see that not all of the code to be inserted is a valid Lisp form.  For
   example, the above instruction referencing ~loopy--iteration-vars~ inserts a
   binding for the variable =list-211= into a ~let~-like form.

   | Place                   | Code                             |
   |-------------------------+----------------------------------|
   | =loopy--iteration-vars= | =(list-211 '(1 2 3))=            |
   | =loopy--latter-body=    | =(setq list-211 (cdr list-211))= |
   | =loopy--pre-conditions= | =(consp list-211)=               |
   | =loopy--iteration-vars= | =(i nil)=                        |
   | =loopy--main-body=      | =(setq i (car list-211)))=       |

   Commands are parsed by ~loopy--parse-loop-command~, which receives a command
   call, such as =(list i '(1 2 3))=, and returns a list of instructions.  It
   does this by searching for an appropriate command-specific parsing function
   in ~loopy-aliases~ and ultimately in ~loopy-command-parsers~.  For
   parsing multiple commands in order, there is ~loopy--parse-loop-commands~,
   which wraps the single-command version.

   For example, consider the function ~loopy--parse-if-command~, which parses
   the =if= loop command.  It needs to check the instructions of the
   sub-commands passed to =if=, looking for code that would be inserted into the
   main loop body (as determined by the first element of the instruction).  Once
   found, it wraps that code with an ~if~-form.

   #+begin_src emacs-lisp
     ;; => ((loopy--iteration-vars (i nil))
     ;;     (loopy--main-body (setq i 1)))
     (loopy--parse-loop-command '(set i 1))

     ;; => ((loopy--iteration-vars (i nil))
     ;;     (loopy--main-body (if (my-condition)
     ;;                           (setq i 1)
     ;;                         (setq i 2))))
     (loopy--parse-if-command '(if (my-condition)
                                   (set i 1)
                                 (set i 2)))
   #+end_src

   For the purpose of this example, below is a version of the parsing function
   made of the basic Lisp features with which you are familiar.  The actual
   definition makes use of more convenient Emacs Lisp libraries and can be seen
   in the library {{{file(loopy-commands.el)}}}.

   #+BEGIN_SRC emacs-lisp
     (require 'loopy-commands)
     (defun loopy--parse-if-command (arg)
       "Parse the `if' loop command usage ARG.
     ARG is of the form (if CONDITION IF-TRUE &rest IF-FALSE)."

       (let ((condition (cadr arg))   ; Second element of `arg'.
             (if-true   (caddr arg))  ; Third element of `arg'.
             (if-false  (cdddr arg))) ; Remaining elements of `arg'.

         ;; The main processing of this function is to separate instructions
         ;; for the loop's main body from other instructions,
         ;; and to then wrap those main-body instructions with an
         ;; `if' special form.
         (let ((full-instructions)
               (if-true-main-body)
               (if-false-main-body)
               ;; This variable is just so that iteration commands know when
               ;; they are being used away from the top level of the loop's
               ;; structure (which is an error).
               (loopy--in-sub-level t))

           ;; Process the instructions for the command that should run if the
           ;; condition is true.
           (dolist (instruction (loopy--parse-loop-command if-true))
             (if (eq 'loopy--main-body (car instruction))
                 (push (cadr instruction) if-true-main-body)
               (push instruction full-instructions)))

           ;; Process the instructions for the commands that should run
           ;; if the condition is false.
           (dolist (instruction (loopy--parse-loop-commands if-false))
             (if (eq 'loopy--main-body (car instruction))
                 (push (cadr instruction) if-false-main-body)
               (push instruction full-instructions)))

           ;; Note: `push' adds elements to the front of a list,
           ;;       so we need to reverse these lists before returning
           ;;       the new list of instructions.

           ;; `loopy--parse-loop-command' always returns a list of instructions.
           ;; For some commands, that means wrapping multiple instructions in
           ;; a `progn' form.  For others, we need to extract the only element.
           (setq if-true-main-body
                 (if (= 1 (length if-true-main-body))
                     (car if-true-main-body)
                   (cons 'progn (nreverse if-true-main-body))))

           ;; Return the new, full list of instructions.
           (cons `(loopy--main-body
                   . (if ,condition
                         ,if-true-main-body
                       ,@(nreverse if-false-main-body)))
                 (nreverse full-instructions)))))
   #+END_SRC

   The hardest part of this exchange is making sure that the inserted code ends
   up in the correct order.

   A loop command has 7 main places to put code:

   #+vindex: loopy--generalized-vars
   - =loopy--generalized-vars= :: Lists of a symbol and a macro
     expansion that will be given to =cl-symbol-macrolet=.  This is used to
     create named ~setf~-able places.  The expansion you use depends on the kind
     of sequence and how the it is updated.

     For example, =(list-ref i my-list)= declares =i= to be a symbol which
     expands to =(car TEMP-VAR)=, in which =TEMP-VAR= holds the value of
     =my-list=.  At the end of the loop body, =TEMP-VAR= is set to its =cdr=,
     ensuring that the next call to =car= returns the correct value.

   #+vindex: loopy--iteration-vars
   - =loopy--iteration-vars= :: Lists of a symbol and an expression that will be
     given to ~let*~.  This is used for initializing variables needed for
     iteration commands, such as the =i= in =(list i '(1 2 3))= or to store the
     list ='(1 2 3)= in =(list i '(1 2 3))=.  This also includes variables
     needed for destructuring.

   #+vindex: loopy--accumulation-vars
   - =loopy--accumulation-vars= :: Lists of a symbol and an expression that will
     be given to ~let*~.  This is used for initializing variables needed for
     accumulation commands, such as the =coll= in =(collect coll my-val)= or any
     variables needed for destructuring.

   #+vindex: loopy--pre-conditions
   - =loopy--pre-conditions= :: Expressions that determine if the =while=
     loop runs/continues, such as whether a list still has elements in it.
     If there is more than one expression, than all expressions are used in
     an =and= special form.

   #+vindex: loopy--main-body
   - =loopy--main-body= :: Expressions that make up the main body of the
     loop.

   #+vindex: loopy--latter-body
   - =loopy--latter-body= :: Expressions that need to be run after the main
     body, such as updating some of variables that determine when a loop ends.

   #+vindex: loopy--post-conditions
   - =loopy--post-conditions= :: Expressions that determine whether the
     =while= loop continues, but checked after the loop body has run.  The
     code from this is ultimately appended to the latter body before being
     substituted in.

   For accumulation commands, you might also wish to place values in the
   following:

   #+vindex: loopy--implicit-return
   - =loopy--implicit-return= :: A list of values to be returned by the loop if
     no other return value is specified/reached. A value is added to this list
     when an accumulation command does not specify an accumulation variable, and
     in some special other cases.

     By default, the implicit return value is ~loopy-result~, and so this
     variable is usually just a list of the symbol =loopy-result=.  When the
     =split= flag is enabled, this is a list of values to which ~loopy-result~
     is bound.

   #+vindex: loopy--accumulation-final-updates
   - =loopy--accumulation-final-updates= :: Actions to perform on the
     accumulation variable after the loop ends.  Some implied accumulation
     commands need to update the variable one final time after ending the loop.
     Some examples are:
     1. Correcting the order of elements in a list that was constructed in
        reverse.
     2. Coercing the variable into a new sequence type, for commands with the
        ~:result-type~ argument.

     Each accumulation variable can only be updated once, in a single way.  For
     example, a variable cannot be reversed according to the needs of one
     command and then coerced into a new type according to the needs of another.
     Commands acting on the same accumulation variable must require the same
     final update, if they require any final update.


   Loopy will attempt to produce efficient code, and will not attempt to set up
   features which are not used.  Therefore, the expanded code depends on the
   kinds of instructions that are returned by the parsing functions.  For the
   most part, the instructions affect the expansion of the loop that contains
   their respective command.  However, there are cases where a command must send
   instructions to a surrounding loop, not just the loop which immediately
   contains it.  Consider using an accumulation command within the =at= command,
   as in the below example.  The accumulation variable must be declared for the
   loop =outer=, but the accumulation itself must still occur within the loop
   =inner=.

   #+begin_src emacs-lisp
     ;; => (1 2 3 4)
     (loopy outer
            (array i [(1 2) (3 4)])
            (sub-loop inner
                      (list j i)
                      (at outer (collect coll j)))
            (finally-return coll))
   #+end_src

   To communicate these instructions, use ~loopy--at-instructions~.  For
   example, the output of parsing =(at outer (collect j :at start))= would be a
   list of instructions similar to those below.  While all of these
   sub-instructions are produced by parsing the =collect= command, not all are
   sent to the loop =outer=.

   #+begin_src emacs-lisp
     ((loopy--at-instructions
       (outer (loopy--accumulation-vars (loopy-result nil))
              (loopy--implicit-return loopy-result)))
      (loopy--main-body (setq loopy-result (cons j loopy-result))))
   #+end_src

   #+vindex: loopy--at-instructions
   - =loopy--at-instructions= :: Instructions that should be interpreted by a
     surrounding loop.  For example, this kind of instruction is used by the
     =at=, =skip-from=, and =leave-from= commands.  The instruction's value is a
     list of a loop name followed by sub-instructions.

     This variable works as a something like a combination of a stack and a map.
     This means that then when multiple surrounding loops share the same name,
     the instructions affect the innermost surrounding loop of that name.


   There are 4 more variables a loop command can push to, but they are derived
   from the macro's arguments.  Adding to them after using a macro argument
   might lead to unintended behavior.  You might wish to use them if, for
   example, you are concerned with what happens after the loop exits/completes.

   #+vindex: loopy--before-do
   - =loopy--before-do= :: Expressions to evaluate before the loop.  These are
     derived from the =before-do= macro argument.

   #+vindex: loopy--after-do
   - =loopy--after-do= :: Expressions to evaluate after the loop completes
     successfully.  These are derived from the =after-do= macro argument.

   #+vindex: loopy--final-do
   - =loopy--final-do= :: Expressions to evaluate after the loop completes,
     regardless of success.  These are derived from the =finally-do= macro
     argument.

   #+vindex: loopy--final-return
   - =loopy--final-return= :: An expression that is always returned by the
     macro, regardless of any early returns in the loop body.  This is
     derived from the =finally-return= macro argument.


   #+vindex: loopy--loop-name
   Some commands might depend on the name of the loop.  The symbol which names
   the loop is stored in the variable ~loopy--loop-name~.  The default value is
   ~nil~ for normal loop and uniquely generated for sub-loops created with the
   =sub-loop= command.

   The structure of the macro’s expanded code depends on the features used
   (e.g., ~loopy~ won’t try to declare variables if none exist), but the result
   will work similar to the below example.

   #+BEGIN_SRC emacs-lisp
     `(cl-symbol-macrolet ,loopy--generalized-vars
        (let* ,loopy--with-vars
          (let ,loopy--accumulation-vars
            (let* ,loopy--iteration-vars
              (let ((loopy--early-return-capture
                     (cl-block ,loopy--loop-name
                       ,@loopy--before-do
                       (catch loopy--non-returning-exit-tag-name
                         (while ,(cl-case (length loopy--pre-conditions)
                                   (0 t)
                                   (1 (car loopy--pre-conditions))
                                   (t (cons 'and loopy--pre-conditions)))
                           (catch loopy--skip-tag-name
                             ,@loopy--main-body)
                           ,@loopy--latter-body
                           (unless ,loopy--post-conditions
                             (cl-return-from ,loopy--loop-name
                               ,loopy--implicit-return)))
                         ,loopy--accumulation-final-updates
                         ,@loopy--after-do))
                     ,loopy--implicit-return))
                ,@loopy--final-do
                ,(if loopy--final-return
                     loopy--final-return
                   'loopy--early-return-capture))))))
   #+END_SRC

** Hello World
   :PROPERTIES:
   :CUSTOM_ID: a-small-example
   :DESCRIPTION: A minimal working example.
   :END:

   To implement a custom loop body command, =loopy= needs two pieces of
   information:
   1. The keyword that names your command
   2. The parsing function that can turn uses of your command into instructions.

   Importantly, your custom commands cannot share a name.

   For example, say that you're tired of typing out
   =(do (message "Hello, %s %s" PERSONAL-NAME FAMILY-NAME))= and would prefer
   to instead use =(greet PERSONAL-NAME [FAMILY-NAME])=.  This only requires
   adding code to the loop's main body, so the definition of the parsing
   function is quite simple.

   #+BEGIN_SRC emacs-lisp
     (require 'cl-lib)
     (cl-defun my-loopy-greet-command-parser
         ((_ personal-name &optional family-name))
       "Greet one with PERSONAL-NAME and optional FAMILY-NAME."
       `((loopy--main-body (if ,family-name
                               (message "Hello, %s %s"
                                        ,personal-name ,family-name)
                             (message "Hello, %s" ,personal-name)))))
   #+END_SRC

   =loopy= will pass the entire command expression to the parsing function, and
   expects back a list of instructions.

   #+vindex: loopy-command-parsers
   To tell =loopy= about this function, add it and the command name =greet= to
   the variable =loopy-command-parsers=, which associates commands with parsing
   functions.  The function that is paired with the symbol receives the entire
   command expression, and should produce a list of valid instructions.

   #+BEGIN_SRC emacs-lisp
     ;; Using the Map library, for convenience.
     (require 'map)
     (setf (map-elt loopy-command-parsers 'greet)
           #'my-loopy-greet-command-parser)
   #+END_SRC

   After that, you can use your custom command in the loop body.

   #+BEGIN_SRC emacs-lisp
     (loopy (list name '(("John" "Deer") ("Jane" "Doe") ("Jimmy")))
            (greet (car name) (cadr name)))
   #+END_SRC

   By running {{{kbd(M-x pp-macroexpand-last-sexp RET)}}} on the above
   expression, you can see that it expands to do what we want, as expected.  You
   might notice that one shortcoming of the current definition is that if a
   function is used to produce the second argument, as in ~(greet
   (personal-name) (family-name))~, then that function is called twice.  This
   occurs with ~(cadr name)~ in the below output, and can cause problems when
   using stateful functions.  This particular case can be resolved by using
   ~if-let~ to first store the result of ~(cadr name)~, and is something to keep
   in mind when defining Lisp macro expansions in general.

   #+BEGIN_SRC emacs-lisp
     ;; An example expansion.
     (let* ((list-166 '(("John" "Deer") ("Jane" "Doe") ("Jimmy")))
            (name nil))
       (let ((loopy-first-iteration t))
         (cl-block nil
           (while (consp list-166)
             (setq name (car list-166))
             (if (cadr name)
                 (message "Hello, %s %s"
                          (car name)
                          (cadr name))
               (message "Hello, %s"
                        (car name)))
             (setq list-166 (cdr list-166))
             (setq loopy-first-iteration nil))
           nil)))
   #+END_SRC

** An ~always~ Command
   :PROPERTIES:
   :CUSTOM_ID: always-example
   :DESCRIPTION: Adding a feature from `cl-loop'.
   :END:

   Lets say we want to emulate ~cl-loop~'s =always= clause, which causes the
   loop to return ~nil~ if an expression evaluates to ~nil~ and ~t~ otherwise.
   This is similar to the functions ~cl-every~ and ~seq-every-p~.

   Here is an example:

   #+BEGIN_SRC emacs-lisp
     ;; => t
     (cl-loop for i from 1 to 9 always (< i 10))
   #+END_SRC

   While ~loopy~ already has an =always= command, we'll ignore it for the sake
   of this example.  Without a custom command, you could translate this using
   the following code:

   #+BEGIN_SRC emacs-lisp
     ;; => t
     (loopy (nums i 1 9)
            (unless (< i 10) (return nil))
            (else-do (cl-return t)))
   #+END_SRC

   This is similar to what you might write in other languages, such as Python.

   #+begin_src python
     # In some testing Python function:
     for i in range(1, 10):
         if not (i < 10):
             return False
     else:
         return True
   #+end_src

   While the meaning of the code is clear, this approach is certainly wordier.

   Here's how one could do this using a custom command.  Again, =loopy= already
   comes with a built-in =always= command.  This example is taken directly from
   the file {{{file(loopy-commands.el)}}}, which contains the code of all of
   ~loopy~'s built-in parsers.

   We can describe the command's desired behavior in two sentences:
   1. The loop should immediately return ~nil~ if the expression ever evaluates
      to ~nil~.
   2. The loop should return ~t~ if the loop is able to complete successfully.

   This simplest way to satisfy the first requirement is to conditionally use
   ~cl-return~ if the expressions ever evaluates to ~nil~.  We want to do this
   while the loop is running, so we should use an instruction for
   ~loopy--main-body~.

   #+begin_src emacs-lisp
     ;; We want to insert the below code into the loop
     (unless CONDITION
       (cl-return nil))

     ;; so we use the instruction
     `(loopy--main-body (unless ,CONDITION (cl-return nil)))

     ;; where CONDITION is supplied by the parsing function.
   #+end_src

   For a simple loop, this works well enough.  However, the function ~cl-return~
   only works with blocks that are named ~nil~.  If we have named the loop, then
   ~cl-return~ won't work, and might instead cause unexpected errors.
   Therefore, it is better to use ~cl-return-from~ with the variable
   ~loopy--loop-name~.  As noted in the previous section, ~loopy--loop-name~
   stores the symbol which names the loop.

   #+begin_src emacs-lisp
     `(loopy--main-body (unless ,CONDITION
                          (cl-return-from ,loopy--loop-name nil)))
   #+end_src

   The best way to satisfy the second requirement is to use an instruction for
   ~loopy--implicit-return~.  One /could/ try to insert code using
   ~cl-return-from~ into ~loopy--after-do~, and this /would/ cause a value to be
   returned after the loop had successfully completed, but doing it that way
   could unexpectedly prevent other code in =after-do= from running.  Using an
   implicit return value does not have that problem.

   This gives us the following instruction, which will add ~t~ to the list of
   values the macro returns if nothing else would be returned.  If that list is
   just ~'(t)~, then the macro knows to just return ~t~.

   #+begin_src emacs-lisp
     '(loopy--implicit-return t)
   #+end_src

   Once we've chosen our instructions, we need to tell =loopy= what function to
   use to produce these instructions.  Like in the previous example, we define
   the parsing function and add it to ~loopy-command-parsers~.

   #+begin_src emacs-lisp
     ;; As noted in the previous section, the parsing function is always
     ;; passed the entire command as `(always CONDTION)', not just the
     ;; command arguments as `CONDITION'.

     (cl-defun my--loopy-always-command-parser ((_ condition))
       "Parse a command of the form `(always CONDITION)'.

     If any condition is nil, `loopy' should immediately return nil.
     Otherwise, `loopy' should return t."
       `((loopy--implicit-return t)
         (loopy--main-body (unless ,condition
                             (cl-return-from ,loopy--loop-name nil)))))

     (setf (map-elt loopy-command-parsers 'always)
           #'my--loopy-always-command-parser)
   #+end_src

   Once we've added our parsing function to ~loopy-command-parsers~,
   =loopy= will use that function whenever it tries to understand the =always=
   command.  In this case, this custom parser would supercede the built-in
   parser.

   With that done, our custom =always= command is as useful as the corresponding
   ~cl-loop~ clause.  However, because ~loopy~ uses expressions instead of
   keyword clauses like ~cl-loop~, we can do slightly better.  For convenience,
   we can easily allow passing multiple conditions to the command instead of
   just one.  In such cases, the conditions should be wrapped in an ~and~ form,
   and that is indeed what the built-in parser does.

   #+begin_src emacs-lisp
     ;; The built-in parser, taken from `loopy-commands.el':
     (cl-defun loopy--parse-always-command ((_ &rest conditions))
       "Parse a command of the form `(always [CONDITIONS])'.

     If any condition is nil, `loopy' should immediately return nil.
     Otherwise, `loopy' should return t."
       `((loopy--implicit-return t)
         ;; If there are multiple conditions, wrap these conditions in `and'.
         (loopy--main-body (unless ,(if (= 1 (length conditions))
                                        (cl-first conditions)
                                      `(and ,@conditions))
                             (cl-return-from ,loopy--loop-name nil)))))
   #+end_src

   Here are some examples of the command in action:

   #+begin_src emacs-lisp
     ;; One condition: => t
     (loopy (list i (number-sequence 1 9)) (always (< i 10)))

     ;; Two conditions: => nil
     (loopy (list i (number-sequence 1 9))
            (list j '(2 4 6 8 9))
            (always (< i 10) (cl-evenp j)))

     ;; The previous example is equivalent to this.
     (loopy (list i (number-sequence 1 9))
            (list j '(2 4 6 8 9))
            (always (and (< i 10) (cl-evenp j))))
   #+end_src


** Finding More Examples
   :PROPERTIES:
   :CUSTOM_ID: finding-more-examples
   :END:

   If you would like to see more examples, consider reading through the source
   code of {{{file(loopy-commands.el)}}}, which contains the code of all of the
   built-in loop commands.  You can easily find this file using
   {{{kbd(M-x find-library loopy-commands RET)}}}.

* Comparing to ~cl-loop~
:PROPERTIES:
:CUSTOM_ID: comparing-to-cl-loop
:DESCRIPTION: Why `loopy' instead of `cl-loop'.
:END:

~loopy~ should be comparable with ~cl-loop~ for most things, keeping in mind the
following:
- ~loopy~ should be as fast or faster than ~cl-loop~, though some optimizations
  are more explicit.
  #+begin_src emacs-lisp
    ;; Compare efficiency of accumulations using
    ;; M-x pp-macroexpand-last-sexp:
    (cl-loop for i in (number-sequence 1 10)
             if (cl-evenp i) collect i into evens
             else collect i into odds
             finally return (list odds evens))

    (loopy (accum-opt odds evens)
           (list i (number-sequence 1 10))
           (if (cl-evenp i)
               (collect evens i)
             (collect odds i))
           (finally-return odds evens))
  #+end_src

- Loop commands are always evaluated in order.

- ~loopy~ has a more flexible set of looping features:
  - Several accumulation commands can accumulate onto the beginning or end of
    the resulting sequence, as in Common Lisp's Iterate.
    #+begin_src emacs-lisp
      ;; => (3 2 1 8 9 10)
      (loopy (array i [1 2 3])
             (collect i :at start)
             (collect (+ i 7) :at end))
    #+end_src

  - It has more flexible control-flow commands, under which you can easily group
    sub-commands, including assignments.
    #+begin_src emacs-lisp
      ;; => ((2 4)
      ;;     ((1 8) (2 9)))
      (loopy (list i '(1 2 3 4))
             (if (cl-evenp i)
                 (collect evens i)
               (set var1 (1+ var1) :init 0)
               (set var2 (+ 7 var1))
               (collect vars (list var1 var2)))
             (finally-return evens vars))((2 4) )
    #+end_src

  - It has a =skip= command to skip the rest of the loop body and immediately
    start the next iteration.  Of course, a similar effect could be achieved
    using the =when= or =unless= commands.
    #+begin_src emacs-lisp
      ;; => (1 3)
      (loopy (list i '(1 2 3))
             (when (= i 2) (skip))
             (collect i))
    #+end_src

- ~loopy~ has more featureful destructuring, which is supported by both
  iteration and accumulation commands.
  #+begin_src emacs-lisp
    ;; => ((1 4) (2 6) (3 5))
    (loopy (array (&whole elem _ &rest rest) [(1 :a 2 :b 3)
                                              (4 :b 5 :a 6)])
           (collect (first) elem)
           (collect (&key a b) rest)
           (finally-return first a b))
  #+end_src

  - Such destructuring is configurable.
    #+begin_src emacs-lisp
      ;; => ((1 3) (2 4))
      (loopy (flag pcase)
             (array elem [(1 2) (3 4)])
             (collect `(,a ,b) elem)
             (finally-return a b))
    #+end_src

- The macro is extensible.


~loopy~ is not always a one-to-one replacement for ~cl-loop~, but it is easy
to use and extend, and performs well in the cases that it already handles.

Below is a simple example of ~loopy~ vs ~cl-loop~.

#+BEGIN_SRC emacs-lisp
  (require 'cl-lib)
  (cl-loop with some-thing = 5
           for i from 1 to 100
           do (message "I is %s" i)
           when (> (+ i 5) 20)
           return (format "Done: %d" i))

  (require 'loopy)
  (loopy (with (some-thing 5))
         (nums i 1 100)
         (do (message "I is %s" i))
         (when (> (+ i 5) 20)
           (return (format "Done: %d" i))))
#+END_SRC

The main benefit (I believe) of Loopy is clearer grouping of commands under
conditionals while still using a clean syntax, such as in the below example.

#+BEGIN_SRC emacs-lisp
  ;; => '((2 4) (4 8) (6 12) (8 16) (10 20))
  (loopy (nums i 1 10)
         (when (cl-evenp i)
           (set once i)
           (set twice (* 2 i))
           (collect doubles (list once twice)))
         (finally-return doubles))
#+END_SRC

In my experience, ~cl-loop~ does not allow the easy grouping of assignment
statements under a =when= condition.  For example, below is something I would
like to try to do with ~cl-loop~.

I am aware that in this example the =for= statements aren't necessary and that
the =collect= statements would be sufficient, but (when I come across things
like this in my work) I would like to use them to declare variables for
readability purposes.

#+BEGIN_SRC emacs-lisp
  (require 'cl-lib)
  (save-match-data
    (cl-loop with pattern = "^Line\\([[:digit:]]\\)-Data\\([[:digit:]]\\)"
             for line in (split-string "Line1-Data1\nBad\nLine2-Data2")
             when (string-match pattern line)
             for line-num = (concat "L" (match-string 1 line))
             and for data-num = (concat "D" (match-string 2 line))

             ;; … Further processing now that data is named …

             and collect line-num into line-nums
             and collect data-num into data-nums
             finally return (list line-nums data-nums)))

  ;; Normal Elisp:
  (save-match-data
    (let ((pattern "^Line\\([[:digit:]]\\)-Data\\([[:digit:]]\\)")
          (line-nums)
          (data-nums))
      (dolist (line (split-string "Line1-Data1\nBad\nLine2-Data2"))
        (when (string-match pattern line)
          (let ((line-num (concat "L" (match-string 1 line)))
                (datum-num (concat "D" (match-string 2 line))))

            ;; … Further processing now that data is named …

            (push line-num line-nums)
            (push datum-num data-nums))))
      (list (nreverse line-nums) (nreverse data-nums))))
#+END_SRC

Here is how one could currently do it with ~loopy~:

#+BEGIN_SRC emacs-lisp
  (require 'loopy)
  (save-match-data
    (loopy (with (pattern "^Line\\([[:digit:]]\\)-Data\\([[:digit:]]\\)"))
           (list line (split-string "Line1-Data1\nBad\nLine2-Data2"))
           (when (string-match pattern line)
             (set line-num (concat "L" (match-string 1 line)))
             (set datum-num (concat "D" (match-string 2 line)))

             ;; … Further processing now that data is named …

             (collect line-nums line-num)
             (collect data-nums datum-num))
           (finally-return line-nums data-nums)))
#+END_SRC

I believe that the value of the macro increases for longer loop bodies with
several conditional commands.

Another nice ability, one that I'm not sure ~cl-loop~ has, is a specific
command for skipping/continuing a loop iteration.  Of course, one could also
re-organize code under a conditional command like =when= to achieve the same
effect.

#+BEGIN_SRC emacs-lisp
  ;; Returns even numbers that aren't multiples of 10.
  ;;
  ;; => (2 4 6 8 12 14 16 18)
  (loopy (nums i 1 20)
         (when (zerop (mod i 10))
           (skip))
         (when (cl-evenp i)
           (collect i)))
#+END_SRC

* Translating to and from =cl-loop=
  :PROPERTIES:
  :CUSTOM_ID: translating-from-cl-loop
  :DESCRIPTION: Converting `cl-loop' to `loopy', and vice versa.
  :END:

  ~loopy~ and ~cl-loop~ use slightly different terminology.  The equivalent of
  "for clauses" are referred to as "iteration commands" in ~loopy~, as they
  generally are used for iterating through sequences.  Meanwhile, "iteration
  clauses" can be separated into "iteration commands" (=repeat= and =iter-by=
  (not yet implemented)) and "early-exit commands" (=while= and =until=).

  "Accumulation clauses" work the same as "accumulation commands".

** For Clauses
   :PROPERTIES:
   :CUSTOM_ID: for-clauses
   :END:

   As Emacs has many functions that return lists, there is no need to implement
   an exact equivalent for every =for=-clause that ~cl-loop~ has.  Instead, one
   can just iterate through the return value of the appropriate function using
   the =list= command.

   For the commands operating on hash tables, see also the generic iteration
   command =map-pairs=, which works generically on hash tables, association
   lists ("alists"), property lists ("plists"), and vectors.

   | ~cl-loop~                                     | ~loopy~                                     |
   |-----------------------------------------------+---------------------------------------------|
   | =for VAR from EXPR1 to EXPR2 by EXPR3=        | =(numbers VAR EXPR1 EXPR2 :by EXPR3)=       |
   | =for VAR in LIST [by FUNCTION]=               | =(list VAR LIST :by FUNC)=                  |
   | =for VAR on LIST [by FUNCTION]=               | =(cons VAR VAL :by FUNC)=                   |
   | =for VAR in-ref LIST by FUNCTION=             | =(list-ref VAR LIST :by FUNC)=              |
   | =for VAR across ARRAY=                        | =(array VAR ARRAY)=                         |
   | =for VAR across-ref ARRAY=                    | =(array-ref VAR ARRAY)=                     |
   | =for VAR being the elements of SEQUENCE=      | =(seq VAR SEQUENCE)=                        |
   | =for VAR being the elements of-ref SEQUENCE=  | =(seq-ref VAR SEQUENCE)=                    |
   | =for VAR being the symbols [of OBARRAY]=      | None so far.  Use ~mapatoms~.               |
   | =for VAR being the hash-keys of HASH-TABLE=   | =(list VAR (hash-table-keys HASH-TABLE))=   |
   | =for VAR being the hash-values of HASH-TABLE= | =(list VAR (hash-table-values HASH-TABLE))= |
   | =for VAR being the key-codes of KEYMAP=       | None so far.  Use ~map-keymap~.             |
   | =for VAR being the key-bindings of KEYMAP=    | None so far.  Use ~map-keymap~.             |
   | =for VAR being the key-seqs of KEYMAP=        | None so far.                                |
   | =for VAR being the overlays [of BUFFER]=      | None so far.  Use ~overlay-lists~.          |
   | =for VAR being the intervals [of BUFFER]=     | None so far.                                |
   | =for VAR being the frames=                    | =(list VAR (frame-list))=                   |
   | =for VAR being the windows [of FRAME]=        | =(list VAR (window-list FRAME))=            |
   | =for VAR being the buffers=                   | =(list VAR (buffer-list))=                  |
   | =for VAR = EXPR1 then EXPR2=                  | =(set VAR EXPR1 EXPR2)=                    |

** Iteration Clauses
   :PROPERTIES:
   :CUSTOM_ID: iteration-clauses
   :END:

   | ~cl-loop~          | ~loopy~          |
   |--------------------+------------------|
   | =repeat INT=       | =(repeat INT)=   |
   | =while COND=       | =(while COND)=   |
   | =until COND=       | =(until COND)=   |
   | =iter-by iterator= | None so far.     |
   | =never=            | =(never COND)=   |
   | =always=           | =(always COND)=  |
   | =thereis=          | =(thereis COND)= |

** Accumulation Clauses
   :PROPERTIES:
   :CUSTOM_ID: accumulation-clauses
   :END:

   Like with ~cl-loop~, in ~loopy~, accumulation commands accumulate into the
   same variable when no =VAR= is given (by default, ~loopy-result~).  If you
   would like accumulation commands to accumulate into separate variables,
   simple provide =VAR= to the command or use the =split= flag ([[#flags][Using Flags]]).

   | ~cl-loop~                | ~loopy~              |
   |--------------------------+----------------------|
   | =append EXPR into VAR=   | =(append VAR EXPR)=  |
   | =collect EXPR into VAR=  | =(collect VAR EXPR)= |
   | =concat EXPR into VAR=   | =(concat VAR EXPR)=  |
   | =count EXPR into VAR=    | =(count VAR EXPR)=   |
   | =maximize EXPR into VAR= | =(max VAR EXPR)=     |
   | =minimize EXPR into VAR= | =(min VAR EXPR)=     |
   | =nconc EXPR into VAR=    | =(nconc VAR EXPR)=   |
   | =sum EXPR into VAR=      | =(sum VAR EXPR)=     |
   | =vconcat EXPR into VAR=  | =(vconcat VAR EXPR)= |

** Other Clauses
   :PROPERTIES:
   :CUSTOM_ID: other-clauses
   :END:

   In ~loopy~, =if=, =when=, and =unless= can take multiple loop commands as
   arguments, and operate more like their Lisp counterparts.

   This means that =if= is not a synonym for =when=.  Just like the normal Lisp
   special form ~if~, =(if COND cmd1 cmd2 cmd3)= only runs =cmd1= if =COND=
   evaluates to non-nil, and only runs commands =cmd2= and =cmd3= if =COND=
   evaluates to ~nil~.

   ~loopy~ also provides the command =cond=, which works like the normal Lisp
   special form ~cond~.

   | ~cl-loop~              | ~loopy~                                     |
   |------------------------+---------------------------------------------|
   | =with var = value=     | =(with (VAR VALUE))= as a macro argument    |
   | =if COND clause=       | =(if COND CMDS)= as a loop command          |
   | =when COND clause=     | =(when COND CMDS)= as a loop command        |
   | =unless COND clause=   | =(unless COND CMDS)= as a loop command      |
   | =named NAME=           | =NAME= as a macro argument                  |
   | =initially [do] EXPRS= | =(before-do EXPRS)= as a macro argument     |
   | =finally [do] EXPRS=   | =(finally-do EXPRS)= as a macro argument    |
   | =finally return EXPR=  | =(finally-return EXPR)= as a macro argument |
   | =do EXPRS=             | =(do EXPRS)= as a loop command              |
   | =return EXPR=          | =(return EXPR)= as a loop command           |


*  Real-World Examples
  :PROPERTIES:
  :DESCRIPTION: Extra example of how one could use `loopy'.
  :END:

  This section contains examples of loops that exist in real-world commands.  To
  see these loops in context, full examples of those commands can be found
  online in the file {{{file(examples/loopy-examples.el)}}} in this package's
  repository [fn:repo].

  One command that could see a benefit from using =loopy= is =selectrum-swiper=
  from the Selectrum wiki [fn:sel-wiki].  This command allows a user to jump to
  a matched line in the buffer.  Candidates are created by looping through text
  lines, formatting non-empty lines and collecting the formatted lines into a
  list of candidates.  At the same time, it selects a default candidate by
  finding the non-empty line closest to the current line.

  Here is the main portion of the command, which uses ~cl-loop~.

  #+begin_src emacs-lisp
    ;; ...
    (cl-loop
     with buffer-lines = (split-string (buffer-string) "\n")
     with number-format = (concat "L%0"
                                  (number-to-string
                                   (length (number-to-string
                                            (length buffer-lines))))
                                  "d: ")

     with formatted-candidates = nil
     for line-text in buffer-lines
     for line-num = (line-number-at-pos (point-min) t) then (1+ line-num)

     with default-candidate = nil
     with prev-distance-to-default-cand = 1.0e+INF ; This updated later.
     for distance-to-default-cand = (abs (- current-line-number line-num))

     unless (string-empty-p line-text)      ; Just skip empty lines.
     do
     ;; Find if we’ve started to move away from the current line.
     (when (null default-candidate)
       (when (> distance-to-default-cand
                prev-distance-to-default-cand)
         (setq default-candidate (cl-first formatted-candidates)))
       (setq prev-distance-to-default-cand distance-to-default-cand))

     ;; Format current line and collect candidate.
     (push (propertize line-text
                       'selectrum-candidate-display-prefix
                       (propertize (format number-format line-num)
                                   'face 'completions-annotations)
                       'line-num line-num)
           formatted-candidates)

     finally return (list default-candidate
                          (nreverse formatted-candidates)))
    ;; ...
  #+end_src

  The limitations of ~cl-loop~'s =when= clause encourages relying on Lisp
  expressions rather than clauses for processing.  To use those Lisp
  expressions, one must declare more variables with the =with= clause to ensure
  that those variables are locally scoped.

  Here is how it could be done with =loopy=:

  #+begin_src emacs-lisp
    ;; ...
    (loopy
     (with (buffer-text-lines (split-string (buffer-string) "\n"))
           (number-format (concat "L%0"
                                  (number-to-string
                                   (length (number-to-string
                                            (length buffer-text-lines))))
                                  "d: ")))
     (list line-text buffer-text-lines)
     (set line-num (line-number-at-pos (point-min) t)
           (1+ line-num))
     (unless (string-empty-p line-text)
       (push-into formatted-candidates
                  (propertize line-text
                              'selectrum-candidate-display-prefix
                              (propertize (format number-format line-num)
                                          'face 'completions-annotations)
                              'line-num line-num))
       ;; There are a few different ways that you could express
       ;; this.
       (when (null default-candidate)
         (set prev-dist +1.0e+INF dist-to-default-cand)
         (set dist-to-default-cand (abs (- current-line-number
                                            line-num)))
         (when (> dist-to-default-cand prev-dist)
           (set default-candidate (cl-second formatted-candidates)))))
     (finally-return default-candidate (nreverse formatted-candidates)))
    ;; ...
  #+end_src

  We can see that most of the loop commands are easily grouped under the
  =unless= command.  This allows for less noise, as we do not need to declare
  variables or fall back to using more Lisp expressions.

  Another good example is the command =selectrum-outline= from the same page.
  This command is similar to =selectrum-swiper=, but has a slightly more
  complicated processing portion.

  The code loops through each line in the buffer, searching for lines that match
  a pre-determined regular expression.  The match data is used to determine the
  heading level (top level, second level, etc.) and the actual heading text.
  The loop produces formatted candidates by prepending this heading text with
  the text of parent headings, as determined by the heading level.  At the same
  time, the loop selects the current heading as the default candidate.

  Instead of using ~cl-loop~, this command is written in conventional Emacs
  Lisp.

  #+begin_src emacs-lisp
    ;; ...
    (let (;; Get the basic information of each heading in the accessible
          ;; portion of the buffer.
          (buffer-lines (split-string (buffer-string) "\n"))
          (line-number 0)
          (line-number-format)

          ;; Finding the default heading
          (default-heading)
          (current-line-number (line-number-at-pos (point)))

          ;; Keeping track of the tree.
          (backwards-prefix-list)
          (prev-heading-text)
          (prev-heading-level)

          ;; Backwards result of the ‘dolist'. Will ‘nreverse’.
          (formatted-headings))

      (setq line-number-format
            (concat "L%0"
                    (number-to-string
                     (length (number-to-string (length buffer-lines))))
                    "d: "))

      (save-match-data
        (dolist (text-line buffer-lines)
          ;; Increment line number when moving to next.
          (cl-incf line-number)
          (when (string-match heading-regexp text-line)
            (let ((heading-text (match-string-no-properties 2 text-line))
                  (heading-level
                   (length (match-string-no-properties 1 text-line))))

              ;; Make sure this has a valid value when we first compare.  The
              ;; first comparison should be equal, so that nothing is
              ;; needlessly added to the prefix list, which causes bad
              ;; formatting.
              (unless prev-heading-level
                (setq prev-heading-level heading-level))

              ;; Decide whether to update the prefix list and the previous
              ;; heading level.
              (cond
               ;; If we've moved to a greater level (further down the tree),
               ;; add the previous heading to the heading prefix list so
               ;; that we can prepend it to the current heading when
               ;; formatting.
               ((> heading-level prev-heading-level)
                (setq backwards-prefix-list (cons prev-heading-text
                                                  backwards-prefix-list)
                      prev-heading-level heading-level))
               ;; Otherwise, if we've moved to a lower level (higher up the
               ;; tree), and need to remove the most recently added prefix
               ;; from the list (i.e., go from '(c b a) back to '(b a)).
               ((< heading-level prev-heading-level)
                (setq backwards-prefix-list (last backwards-prefix-list
                                                  heading-level)
                      prev-heading-level heading-level)))

              ;; Regardless of what happens, update the previous heading text.
              (setq prev-heading-text heading-text)

              ;; Decide whether the previous formatted heading was the
              ;; default.
              (when (and (null default-heading)
                         (> line-number current-line-number))
                (setq default-heading (cl-first formatted-headings)))

              ;; Finally, add to list of formatted headings.
              ;; Create heading of form "L#: a/b/c" as:
              ;; - having a text property holding the line number
              ;; - prepended with a formatted line number,
              ;;   with the face ‘completions-annotations’.
              (push (propertize
                     (concat (string-join (reverse backwards-prefix-list) "/")
                             (and backwards-prefix-list "/")
                             heading-text)
                     'line-number line-number
                     'selectrum-candidate-display-prefix
                     (propertize
                      (format line-number-format line-number)
                      'face 'completions-annotations))
                    formatted-headings)))))
      ;; ...
      )
  #+end_src

  Here is a version in =loopy= (which is more of a straight translation than a
  re-working):

  #+begin_src emacs-lisp
    ;; ...
    (loopy
     (with (buffer-lines (split-string (buffer-string) "\n"))
           (line-number-format
            (concat "L%0"
                    (number-to-string
                     (length (number-to-string (length buffer-lines))))
                    "d: ")))
     (set line-number 1 (1+ line-number))
     (list text-line buffer-lines)
     (when (string-match heading-regexp text-line)
       (set heading-text
             (match-string-no-properties 2 text-line))
       (set heading-level
             (length (match-string-no-properties 1 text-line)))

       ;; Decide whether to update the prefix list and the previous
       ;; heading level.
       (cond
        ;; If we've moved to a greater level (further down the tree),
        ;; add the previous heading to the heading prefix list so that
        ;; we can prepend it to the current heading when formatting.
        ((> heading-level (or prev-heading-level heading-level))

         (push-into backwards-prefix-list prev-heading-text)
         (set prev-heading-level heading-level))
        ;; Otherwise, if we've moved to a lower level (higher up the
        ;; tree), and need to remove the most recently added prefix
        ;; from the list (i.e., go from '(c b a) back to '(b a)).
        ((< heading-level (or prev-heading-level heading-level))
         (set backwards-prefix-list (last backwards-prefix-list
                                           heading-level))
         (set prev-heading-level heading-level)))

       ;; Regardless of what happens, update the previous heading
       ;; text.
       (set prev-heading-text heading-text)

       ;; Decide whether the previous formatted heading was the
       ;; default.
       (when (and (null default-heading)
                  (> line-number current-line-number))
         (set default-heading (car formatted-headings)))

       ;; Finally, add to list of formatted headings.
       ;; Create heading of form "L#: a/b/c" as:
       ;; - having a text property holding the line number
       ;; - prepended with a formatted line number,
       ;;   with the face ‘completions-annotations’.
       (push-into
        formatted-headings
        (propertize
         (concat (string-join
                  (reverse backwards-prefix-list) "/")
                 (and backwards-prefix-list "/")
                 heading-text)
         'line-number line-number
         'selectrum-candidate-display-prefix
         (propertize (format line-number-format line-number)
                     'face 'completions-annotations))))
     (finally-return default-heading (nreverse formatted-headings)))
    ;; ...
  #+end_src

  In my opinion, the =loopy= version is a bit cleaner.  Even when following the
  same flow of logic, you still get the benefit of less typing with no loss in
  clarity.

  If one were writing code like this often (say, in a library), then the loop
  body could be simplified even further with custom commands
  ([[#adding-custom-commands]]).

* Macro Argument and Loop Command Index
  :PROPERTIES:
  :INDEX: fn
  :END:

* Variable Index
  :PROPERTIES:
  :INDEX: vr
  :END:

* Concept Index
  :PROPERTIES:
  :INDEX: cp
  :END:

* Footnotes

[fn:1] Strings being a kind of array.  See [[info:elisp#Sequences Arrays Vectors]]
for more.

[fn:iter] https://common-lisp.net/project/iterate/

[fn:repo] [[https://github.com/okamsn/loopy]]

[fn:sel-wiki]
[[https://github.com/raxod502/selectrum/wiki/Useful-Commands#swiper-like-jumping-to-matching-lines]]
# Local Variables:
# toc-org-max-depth: 20
# sentence-end-double-space: t
# org-adapt-indentation: nil
# End:

#  LocalWords:  alists plists Loopy's
